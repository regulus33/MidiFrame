{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar BinarySearch_1 = require(\"./BinarySearch\");\n\nvar privatePPQMap = new WeakMap();\n/**\n * @hidden\n */\n\nexports.keySignatureKeys = [\"Cb\", \"Gb\", \"Db\", \"Ab\", \"Eb\", \"Bb\", \"F\", \"C\", \"G\", \"D\", \"A\", \"E\", \"B\", \"F#\", \"C#\"];\n/** The parsed midi file header */\n\nvar Header =\n/** @class */\nfunction () {\n  function Header(midiData) {\n    // look through all the tracks for tempo changes\n    var _this = this;\n    /**\n     * The array of all the tempo events\n     */\n\n\n    this.tempos = [];\n    /**\n     * The time signatures\n     */\n\n    this.timeSignatures = [];\n    /**\n     * The time signatures\n     */\n\n    this.keySignatures = [];\n    /**\n     * Additional meta events\n     */\n\n    this.meta = [];\n    /**\n     * The name of the midi file\n     */\n\n    this.name = \"\";\n    privatePPQMap.set(this, 480);\n\n    if (midiData) {\n      privatePPQMap.set(this, midiData.header.ticksPerBeat); // check time signature and tempo events from all of the tracks\n\n      midiData.tracks.forEach(function (track) {\n        return track.forEach(function (event) {\n          if (event.meta) {\n            if (event.type === \"timeSignature\") {\n              _this.timeSignatures.push({\n                ticks: event.absoluteTime,\n                timeSignature: [event.numerator, event.denominator]\n              });\n            } else if (event.type === \"setTempo\") {\n              _this.tempos.push({\n                bpm: 60000000 / event.microsecondsPerBeat,\n                ticks: event.absoluteTime\n              });\n            } else if (event.type === \"keySignature\") {\n              _this.keySignatures.push({\n                key: exports.keySignatureKeys[event.key + 7],\n                scale: event.scale === 0 ? \"major\" : \"minor\",\n                ticks: event.absoluteTime\n              });\n            }\n          }\n        });\n      }); // check the first track for other relevant data\n\n      midiData.tracks[0].forEach(function (event) {\n        if (event.meta) {\n          if (event.type === \"trackName\") {\n            _this.name = event.text;\n          } else if (event.type === \"text\" || event.type === \"cuePoint\" || event.type === \"marker\" || event.type === \"lyrics\") {\n            _this.meta.push({\n              text: event.text,\n              ticks: event.absoluteTime,\n              type: event.type\n            });\n          }\n        }\n      });\n      this.update();\n    }\n  }\n  /**\n   * This must be invoked after any changes are made to the tempo array\n   * or the timeSignature array for the updated values to be reflected.\n   */\n\n\n  Header.prototype.update = function () {\n    var _this = this;\n\n    var currentTime = 0;\n    var lastEventBeats = 0; // make sure it's sorted\n\n    this.tempos.sort(function (a, b) {\n      return a.ticks - b.ticks;\n    });\n    this.tempos.forEach(function (event, index) {\n      var lastBPM = index > 0 ? _this.tempos[index - 1].bpm : _this.tempos[0].bpm;\n      var beats = event.ticks / _this.ppq - lastEventBeats;\n      var elapsedSeconds = 60 / lastBPM * beats;\n      event.time = elapsedSeconds + currentTime;\n      currentTime = event.time;\n      lastEventBeats += beats;\n    });\n    this.timeSignatures.sort(function (a, b) {\n      return a.ticks - b.ticks;\n    });\n    this.timeSignatures.forEach(function (event, index) {\n      var lastEvent = index > 0 ? _this.timeSignatures[index - 1] : _this.timeSignatures[0];\n      var elapsedBeats = (event.ticks - lastEvent.ticks) / _this.ppq;\n      var elapsedMeasures = elapsedBeats / lastEvent.timeSignature[0] / (lastEvent.timeSignature[1] / 4);\n      lastEvent.measures = lastEvent.measures || 0;\n      event.measures = elapsedMeasures + lastEvent.measures;\n    });\n  };\n  /**\n   * Convert ticks into seconds based on the tempo changes\n   */\n\n\n  Header.prototype.ticksToSeconds = function (ticks) {\n    // find the relevant position\n    var index = BinarySearch_1.search(this.tempos, ticks);\n\n    if (index !== -1) {\n      var tempo = this.tempos[index];\n      var tempoTime = tempo.time;\n      var elapsedBeats = (ticks - tempo.ticks) / this.ppq;\n      return tempoTime + 60 / tempo.bpm * elapsedBeats;\n    } else {\n      // assume 120\n      var beats = ticks / this.ppq;\n      return 60 / 120 * beats;\n    }\n  };\n  /**\n   * Convert ticks into measures based off of the time signatures\n   */\n\n\n  Header.prototype.ticksToMeasures = function (ticks) {\n    var index = BinarySearch_1.search(this.timeSignatures, ticks);\n\n    if (index !== -1) {\n      var timeSigEvent = this.timeSignatures[index];\n      var elapsedBeats = (ticks - timeSigEvent.ticks) / this.ppq;\n      return timeSigEvent.measures + elapsedBeats / (timeSigEvent.timeSignature[0] / timeSigEvent.timeSignature[1]) / 4;\n    } else {\n      return ticks / this.ppq / 4;\n    }\n  };\n\n  Object.defineProperty(Header.prototype, \"ppq\", {\n    /**\n     * The number of ticks per quarter note\n     */\n    get: function get() {\n      return privatePPQMap.get(this);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Convert seconds to ticks based on the tempo events\n   */\n\n  Header.prototype.secondsToTicks = function (seconds) {\n    // find the relevant position\n    var index = BinarySearch_1.search(this.tempos, seconds, \"time\");\n\n    if (index !== -1) {\n      var tempo = this.tempos[index];\n      var tempoTime = tempo.time;\n      var elapsedTime = seconds - tempoTime;\n      var elapsedBeats = elapsedTime / (60 / tempo.bpm);\n      return Math.round(tempo.ticks + elapsedBeats * this.ppq);\n    } else {\n      // assume 120\n      var beats = seconds / (60 / 120);\n      return Math.round(beats * this.ppq);\n    }\n  };\n  /**\n   * Convert the header into an object.\n   */\n\n\n  Header.prototype.toJSON = function () {\n    return {\n      keySignatures: this.keySignatures,\n      meta: this.meta,\n      name: this.name,\n      ppq: this.ppq,\n      tempos: this.tempos.map(function (t) {\n        return {\n          bpm: t.bpm,\n          ticks: t.ticks\n        };\n      }),\n      timeSignatures: this.timeSignatures\n    };\n  };\n  /**\n   * parse a header json object.\n   */\n\n\n  Header.prototype.fromJSON = function (json) {\n    this.name = json.name; // clone all the attributes\n\n    this.tempos = json.tempos.map(function (t) {\n      return Object.assign({}, t);\n    });\n    this.timeSignatures = json.timeSignatures.map(function (t) {\n      return Object.assign({}, t);\n    });\n    this.keySignatures = json.keySignatures.map(function (t) {\n      return Object.assign({}, t);\n    });\n    this.meta = json.meta.map(function (t) {\n      return Object.assign({}, t);\n    });\n    privatePPQMap.set(this, json.ppq);\n    this.update();\n  };\n  /**\n   * Update the tempo of the midi to a single tempo. Will remove and replace\n   * any other tempos currently set and update all of the event timing.\n   * @param bpm The tempo in beats per second\n   */\n\n\n  Header.prototype.setTempo = function (bpm) {\n    this.tempos = [{\n      bpm: bpm,\n      ticks: 0\n    }];\n    this.update();\n  };\n\n  return Header;\n}();\n\nexports.Header = Header;","map":null,"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nimport { Controller } from \"stimulus\";\nimport { Midi } from '@tonejs/midi';\nimport { savePattern } from '../../helpers/network';\n\nvar _default = /*#__PURE__*/function (_Controller) {\n  _inherits(_default, _Controller);\n\n  var _super = _createSuper(_default);\n\n  function _default() {\n    _classCallCheck(this, _default);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(_default, [{\n    key: \"connect\",\n    // open midi file, \n    // convert each note on event to a midi frame note \n    // { note: event.note.number, timestamp: 234 }\n    // send as a POST to patterns/:id \n    value: function () {\n      var _connect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                //   MidiParser.parse( this.midiFileTarget, (obj)=>{\n                //     console.log(obj);\n                //  });\n                // console.log();  \n                this.formatMidiFileData = this.formatMidiFileData.bind(this);\n                this.onFilePick = this.onFilePick.bind(this);\n\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function connect() {\n        return _connect.apply(this, arguments);\n      }\n\n      return connect;\n    }()\n  }, {\n    key: \"formatMidiFileData\",\n    value: function formatMidiFileData(event) {\n      // determine actual duration of ticks in milliseconds based on bpm and ppqn \n      // FORMULA: 60000 / (BPM * PPQ)\n      var arrayBuffer = event.target.result;\n      var midi = new Midi(arrayBuffer);\n      var tempos = midi.header.tempos;\n\n      if (tempos.length > 1) {\n        alert('Sorry, we dont support tempo changes yet :(');\n        return;\n      }\n\n      var bpm = tempos[0].bpm;\n      var ppqn = midi.header.ppq;\n      var tickDurationInMilliseconds = 60000 / (bpm * ppqn);\n      var formattedForBackend = this.realtTimeEventsArray(midi.tracks[0].notes, tickDurationInMilliseconds);\n      var projectId = this.element.getAttribute(\"data-midi-parser-projectId\");\n      var patternId = this.element.getAttribute(\"data-midi-parser-patternId\");\n      var channel = this.element.getAttribute(\"data-midi-parser-channel\");\n      return savePattern({\n        midiEvents: formattedForBackend,\n        patternId: patternId,\n        projectId: projectId,\n        channel: channel,\n        pianoTextData: {},\n        pianoData: {},\n        midiType: \"FILE\"\n      }); // TODO: post to backend and process me!!!! \n      // insert a start time.. \n    }\n  }, {\n    key: \"realtTimeEventsArray\",\n    value: function realtTimeEventsArray(events, tickDuration) {\n      return events.map(function (event) {\n        return {\n          note: event.midi,\n          timestamp: event.ticks * tickDuration\n        };\n      });\n    }\n  }, {\n    key: \"onFilePick\",\n    value: function () {\n      var _onFilePick = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(event) {\n        var file, reader;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                file = event.target.files[0];\n\n                if (!(file.type != \"audio/midi\")) {\n                  _context2.next = 4;\n                  break;\n                }\n\n                alert('Midi files only please');\n                return _context2.abrupt(\"return\");\n\n              case 4:\n                debugger;\n                this.fileNameTarget.innerText = file.name;\n                reader = new FileReader();\n                reader.onloadend = this.formatMidiFileData;\n                reader.readAsArrayBuffer(file);\n\n              case 9:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function onFilePick(_x) {\n        return _onFilePick.apply(this, arguments);\n      }\n\n      return onFilePick;\n    }()\n  }]);\n\n  return _default;\n}(Controller);\n\n_default.targets = ['midiFile', 'fileName'];\nexport { _default as default };","map":{"version":3,"sources":["/Users/zack/andrWert43h/app/javascript/controllers/patterns/midi_parser_controller.js"],"names":["Controller","Midi","savePattern","formatMidiFileData","bind","onFilePick","event","arrayBuffer","target","result","midi","tempos","header","length","alert","bpm","ppqn","ppq","tickDurationInMilliseconds","formattedForBackend","realtTimeEventsArray","tracks","notes","projectId","element","getAttribute","patternId","channel","midiEvents","pianoTextData","pianoData","midiType","events","tickDuration","map","note","timestamp","ticks","file","files","type","fileNameTarget","innerText","name","reader","FileReader","onloadend","readAsArrayBuffer","targets"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAASA,UAAT,QAA2B,UAA3B;AACA,SAASC,IAAT,QAAqB,cAArB;AACA,SAASC,WAAT,QAA4B,uBAA5B;;;;;;;;;;;;;;;AAKE;AACA;AACA;AACA;;;;;;;AAEA;AACA;AACA;AACE;AACA,qBAAKC,kBAAL,GAA0B,KAAKA,kBAAL,CAAwBC,IAAxB,CAA6B,IAA7B,CAA1B;AACA,qBAAKC,UAAL,GAAkB,KAAKA,UAAL,CAAgBD,IAAhB,CAAqB,IAArB,CAAlB;;;;;;;;;;;;;;;;;;uCAGiBE,K,EAAO;AACxB;AACA;AACA,UAAMC,WAAW,GAAGD,KAAK,CAACE,MAAN,CAAaC,MAAjC;AACA,UAAMC,IAAI,GAAG,IAAIT,IAAJ,CAASM,WAAT,CAAb;AACA,UAAMI,MAAM,GAAGD,IAAI,CAACE,MAAL,CAAYD,MAA3B;;AACA,UAAIA,MAAM,CAACE,MAAP,GAAgB,CAApB,EAAuB;AACrBC,QAAAA,KAAK,CAAC,6CAAD,CAAL;AACA;AACD;;AACD,UAAMC,GAAG,GAAGJ,MAAM,CAAC,CAAD,CAAN,CAAUI,GAAtB;AACA,UAAMC,IAAI,GAAGN,IAAI,CAACE,MAAL,CAAYK,GAAzB;AACA,UAAMC,0BAA0B,GAAG,SAASH,GAAG,GAAGC,IAAf,CAAnC;AACA,UAAMG,mBAAmB,GAAG,KAAKC,oBAAL,CAA0BV,IAAI,CAACW,MAAL,CAAY,CAAZ,EAAeC,KAAzC,EAAgDJ,0BAAhD,CAA5B;AACA,UAAMK,SAAS,GAAG,KAAKC,OAAL,CAAaC,YAAb,CAA0B,4BAA1B,CAAlB;AACA,UAAMC,SAAS,GAAG,KAAKF,OAAL,CAAaC,YAAb,CAA0B,4BAA1B,CAAlB;AACA,UAAME,OAAO,GAAG,KAAKH,OAAL,CAAaC,YAAb,CAA0B,0BAA1B,CAAhB;AACA,aAAOvB,WAAW,CAAC;AACjB0B,QAAAA,UAAU,EAAET,mBADK;AAEjBO,QAAAA,SAAS,EAAEA,SAFM;AAGjBH,QAAAA,SAAS,EAAEA,SAHM;AAIjBI,QAAAA,OAAO,EAAEA,OAJQ;AAKjBE,QAAAA,aAAa,EAAE,EALE;AAMjBC,QAAAA,SAAS,EAAE,EANM;AAOjBC,QAAAA,QAAQ,EAAE;AAPO,OAAD,CAAlB,CAjBwB,CA0BxB;AACA;AACD;;;yCAEoBC,M,EAAQC,Y,EAAc;AACzC,aAAOD,MAAM,CAACE,GAAP,CAAW,UAAC5B,KAAD,EAAW;AAC3B,eAAO;AAAE6B,UAAAA,IAAI,EAAE7B,KAAK,CAACI,IAAd;AAAoB0B,UAAAA,SAAS,EAAG9B,KAAK,CAAC+B,KAAN,GAAcJ;AAA9C,SAAP;AACD,OAFM,CAAP;AAGD;;;;mGAEgB3B,K;;;;;;AACTgC,gBAAAA,I,GAAOhC,KAAK,CAACE,MAAN,CAAa+B,KAAb,CAAmB,CAAnB,C;;sBACTD,IAAI,CAACE,IAAL,IAAa,Y;;;;;AACf1B,gBAAAA,KAAK,CAAC,wBAAD,CAAL;;;;AAGF;AACA,qBAAK2B,cAAL,CAAoBC,SAApB,GAAgCJ,IAAI,CAACK,IAArC;AACMC,gBAAAA,M,GAAS,IAAIC,UAAJ,E;AACfD,gBAAAA,MAAM,CAACE,SAAP,GAAmB,KAAK3C,kBAAxB;AACAyC,gBAAAA,MAAM,CAACG,iBAAP,CAAyBT,IAAzB;;;;;;;;;;;;;;;;;;;EA9DyBtC,U;;SAEpBgD,O,GAAU,CAAC,UAAD,EAAa,UAAb,C","sourcesContent":["import { Controller } from \"stimulus\";\nimport { Midi } from '@tonejs/midi';\nimport { savePattern } from '../../helpers/network';\n\nexport default class extends Controller {\n\n  static targets = ['midiFile', 'fileName'];\n  // open midi file, \n  // convert each note on event to a midi frame note \n  // { note: event.note.number, timestamp: 234 }\n  // send as a POST to patterns/:id \n  async connect() { \n  //   MidiParser.parse( this.midiFileTarget, (obj)=>{\n  //     console.log(obj);\n  //  });\n    // console.log();  \n    this.formatMidiFileData = this.formatMidiFileData.bind(this);\n    this.onFilePick = this.onFilePick.bind(this);\n  }\n\n  formatMidiFileData(event) {\n    // determine actual duration of ticks in milliseconds based on bpm and ppqn \n    // FORMULA: 60000 / (BPM * PPQ)\n    const arrayBuffer = event.target.result;\n    const midi = new Midi(arrayBuffer);\n    const tempos = midi.header.tempos;\n    if (tempos.length > 1) {\n      alert('Sorry, we dont support tempo changes yet :(');\n      return;\n    } \n    const bpm = tempos[0].bpm;\n    const ppqn = midi.header.ppq; \n    const tickDurationInMilliseconds = 60000 / (bpm * ppqn);\n    const formattedForBackend = this.realtTimeEventsArray(midi.tracks[0].notes, tickDurationInMilliseconds);\n    const projectId = this.element.getAttribute(\"data-midi-parser-projectId\");\n    const patternId = this.element.getAttribute(\"data-midi-parser-patternId\");\n    const channel = this.element.getAttribute(\"data-midi-parser-channel\");\n    return savePattern({\n      midiEvents: formattedForBackend,\n      patternId: patternId,\n      projectId: projectId,\n      channel: channel,\n      pianoTextData: {},\n      pianoData: {},\n      midiType: \"FILE\",\n    });\n    // TODO: post to backend and process me!!!! \n    // insert a start time.. \n  }\n\n  realtTimeEventsArray(events, tickDuration) {\n    return events.map((event) => {\n      return { note: event.midi, timestamp: (event.ticks * tickDuration) };\n    }); \n  }\n  \n  async onFilePick(event) {\n    const file = event.target.files[0];\n    if (file.type != \"audio/midi\") {\n      alert('Midi files only please');\n      return;\n    }\n    debugger \n    this.fileNameTarget.innerText = file.name \n    const reader = new FileReader();\n    reader.onloadend = this.formatMidiFileData;\n    reader.readAsArrayBuffer(file);\n  }\n\n} "]},"metadata":{},"sourceType":"module"}
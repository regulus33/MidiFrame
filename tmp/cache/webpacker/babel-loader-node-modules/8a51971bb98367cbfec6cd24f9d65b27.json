{"ast":null,"code":"// data can be any array-like object.  It just needs to support .length, .slice, and an element getter []\nfunction parseMidi(data) {\n  var p = new Parser(data);\n  var headerChunk = p.readChunk();\n  if (headerChunk.id != 'MThd') throw \"Bad MIDI file.  Expected 'MHdr', got: '\" + headerChunk.id + \"'\";\n  var header = parseHeader(headerChunk.data);\n  var tracks = [];\n\n  for (var i = 0; !p.eof() && i < header.numTracks; i++) {\n    var trackChunk = p.readChunk();\n    if (trackChunk.id != 'MTrk') throw \"Bad MIDI file.  Expected 'MTrk', got: '\" + trackChunk.id + \"'\";\n    var track = parseTrack(trackChunk.data);\n    tracks.push(track);\n  }\n\n  return {\n    header: header,\n    tracks: tracks\n  };\n}\n\nfunction parseHeader(data) {\n  var p = new Parser(data);\n  var format = p.readUInt16();\n  var numTracks = p.readUInt16();\n  var result = {\n    format: format,\n    numTracks: numTracks\n  };\n  var timeDivision = p.readUInt16();\n\n  if (timeDivision & 0x8000) {\n    result.framesPerSecond = 0x100 - (timeDivision >> 8);\n    result.ticksPerFrame = timeDivision & 0xFF;\n  } else {\n    result.ticksPerBeat = timeDivision;\n  }\n\n  return result;\n}\n\nfunction parseTrack(data) {\n  var p = new Parser(data);\n  var events = [];\n\n  while (!p.eof()) {\n    var event = readEvent();\n    events.push(event);\n  }\n\n  return events;\n  var lastEventTypeByte = null;\n\n  function readEvent() {\n    var event = {};\n    event.deltaTime = p.readVarInt();\n    var eventTypeByte = p.readUInt8();\n\n    if ((eventTypeByte & 0xf0) === 0xf0) {\n      // system / meta event\n      if (eventTypeByte === 0xff) {\n        // meta event\n        event.meta = true;\n        var metatypeByte = p.readUInt8();\n        var length = p.readVarInt();\n\n        switch (metatypeByte) {\n          case 0x00:\n            event.type = 'sequenceNumber';\n            if (length !== 2) throw \"Expected length for sequenceNumber event is 2, got \" + length;\n            event.number = p.readUInt16();\n            return event;\n\n          case 0x01:\n            event.type = 'text';\n            event.text = p.readString(length);\n            return event;\n\n          case 0x02:\n            event.type = 'copyrightNotice';\n            event.text = p.readString(length);\n            return event;\n\n          case 0x03:\n            event.type = 'trackName';\n            event.text = p.readString(length);\n            return event;\n\n          case 0x04:\n            event.type = 'instrumentName';\n            event.text = p.readString(length);\n            return event;\n\n          case 0x05:\n            event.type = 'lyrics';\n            event.text = p.readString(length);\n            return event;\n\n          case 0x06:\n            event.type = 'marker';\n            event.text = p.readString(length);\n            return event;\n\n          case 0x07:\n            event.type = 'cuePoint';\n            event.text = p.readString(length);\n            return event;\n\n          case 0x20:\n            event.type = 'channelPrefix';\n            if (length != 1) throw \"Expected length for channelPrefix event is 1, got \" + length;\n            event.channel = p.readUInt8();\n            return event;\n\n          case 0x21:\n            event.type = 'portPrefix';\n            if (length != 1) throw \"Expected length for portPrefix event is 1, got \" + length;\n            event.port = p.readUInt8();\n            return event;\n\n          case 0x2f:\n            event.type = 'endOfTrack';\n            if (length != 0) throw \"Expected length for endOfTrack event is 0, got \" + length;\n            return event;\n\n          case 0x51:\n            event.type = 'setTempo';\n            if (length != 3) throw \"Expected length for setTempo event is 3, got \" + length;\n            event.microsecondsPerBeat = p.readUInt24();\n            return event;\n\n          case 0x54:\n            event.type = 'smpteOffset';\n            if (length != 5) throw \"Expected length for smpteOffset event is 5, got \" + length;\n            var hourByte = p.readUInt8();\n            var FRAME_RATES = {\n              0x00: 24,\n              0x20: 25,\n              0x40: 29,\n              0x60: 30\n            };\n            event.frameRate = FRAME_RATES[hourByte & 0x60];\n            event.hour = hourByte & 0x1f;\n            event.min = p.readUInt8();\n            event.sec = p.readUInt8();\n            event.frame = p.readUInt8();\n            event.subFrame = p.readUInt8();\n            return event;\n\n          case 0x58:\n            event.type = 'timeSignature';\n            if (length != 4) throw \"Expected length for timeSignature event is 4, got \" + length;\n            event.numerator = p.readUInt8();\n            event.denominator = 1 << p.readUInt8();\n            event.metronome = p.readUInt8();\n            event.thirtyseconds = p.readUInt8();\n            return event;\n\n          case 0x59:\n            event.type = 'keySignature';\n            if (length != 2) throw \"Expected length for keySignature event is 2, got \" + length;\n            event.key = p.readInt8();\n            event.scale = p.readUInt8();\n            return event;\n\n          case 0x7f:\n            event.type = 'sequencerSpecific';\n            event.data = p.readBytes(length);\n            return event;\n\n          default:\n            event.type = 'unknownMeta';\n            event.data = p.readBytes(length);\n            event.metatypeByte = metatypeByte;\n            return event;\n        }\n      } else if (eventTypeByte == 0xf0) {\n        event.type = 'sysEx';\n        var length = p.readVarInt();\n        event.data = p.readBytes(length);\n        return event;\n      } else if (eventTypeByte == 0xf7) {\n        event.type = 'endSysEx';\n        var length = p.readVarInt();\n        event.data = p.readBytes(length);\n        return event;\n      } else {\n        throw \"Unrecognised MIDI event type byte: \" + eventTypeByte;\n      }\n    } else {\n      // channel event\n      var param1;\n\n      if ((eventTypeByte & 0x80) === 0) {\n        // running status - reuse lastEventTypeByte as the event type.\n        // eventTypeByte is actually the first parameter\n        if (lastEventTypeByte === null) throw \"Running status byte encountered before status byte\";\n        param1 = eventTypeByte;\n        eventTypeByte = lastEventTypeByte;\n        event.running = true;\n      } else {\n        param1 = p.readUInt8();\n        lastEventTypeByte = eventTypeByte;\n      }\n\n      var eventType = eventTypeByte >> 4;\n      event.channel = eventTypeByte & 0x0f;\n\n      switch (eventType) {\n        case 0x08:\n          event.type = 'noteOff';\n          event.noteNumber = param1;\n          event.velocity = p.readUInt8();\n          return event;\n\n        case 0x09:\n          var velocity = p.readUInt8();\n          event.type = velocity === 0 ? 'noteOff' : 'noteOn';\n          event.noteNumber = param1;\n          event.velocity = velocity;\n          if (velocity === 0) event.byte9 = true;\n          return event;\n\n        case 0x0a:\n          event.type = 'noteAftertouch';\n          event.noteNumber = param1;\n          event.amount = p.readUInt8();\n          return event;\n\n        case 0x0b:\n          event.type = 'controller';\n          event.controllerType = param1;\n          event.value = p.readUInt8();\n          return event;\n\n        case 0x0c:\n          event.type = 'programChange';\n          event.programNumber = param1;\n          return event;\n\n        case 0x0d:\n          event.type = 'channelAftertouch';\n          event.amount = param1;\n          return event;\n\n        case 0x0e:\n          event.type = 'pitchBend';\n          event.value = param1 + (p.readUInt8() << 7) - 0x2000;\n          return event;\n\n        default:\n          throw \"Unrecognised MIDI event type: \" + eventType;\n      }\n    }\n  }\n}\n\nfunction Parser(data) {\n  this.buffer = data;\n  this.bufferLen = this.buffer.length;\n  this.pos = 0;\n}\n\nParser.prototype.eof = function () {\n  return this.pos >= this.bufferLen;\n};\n\nParser.prototype.readUInt8 = function () {\n  var result = this.buffer[this.pos];\n  this.pos += 1;\n  return result;\n};\n\nParser.prototype.readInt8 = function () {\n  var u = this.readUInt8();\n  if (u & 0x80) return u - 0x100;else return u;\n};\n\nParser.prototype.readUInt16 = function () {\n  var b0 = this.readUInt8(),\n      b1 = this.readUInt8();\n  return (b0 << 8) + b1;\n};\n\nParser.prototype.readInt16 = function () {\n  var u = this.readUInt16();\n  if (u & 0x8000) return u - 0x10000;else return u;\n};\n\nParser.prototype.readUInt24 = function () {\n  var b0 = this.readUInt8(),\n      b1 = this.readUInt8(),\n      b2 = this.readUInt8();\n  return (b0 << 16) + (b1 << 8) + b2;\n};\n\nParser.prototype.readInt24 = function () {\n  var u = this.readUInt24();\n  if (u & 0x800000) return u - 0x1000000;else return u;\n};\n\nParser.prototype.readUInt32 = function () {\n  var b0 = this.readUInt8(),\n      b1 = this.readUInt8(),\n      b2 = this.readUInt8(),\n      b3 = this.readUInt8();\n  return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;\n};\n\nParser.prototype.readBytes = function (len) {\n  var bytes = this.buffer.slice(this.pos, this.pos + len);\n  this.pos += len;\n  return bytes;\n};\n\nParser.prototype.readString = function (len) {\n  var bytes = this.readBytes(len);\n  return String.fromCharCode.apply(null, bytes);\n};\n\nParser.prototype.readVarInt = function () {\n  var result = 0;\n\n  while (!this.eof()) {\n    var b = this.readUInt8();\n\n    if (b & 0x80) {\n      result += b & 0x7f;\n      result <<= 7;\n    } else {\n      // b is last byte\n      return result + b;\n    }\n  } // premature eof\n\n\n  return result;\n};\n\nParser.prototype.readChunk = function () {\n  var id = this.readString(4);\n  var length = this.readUInt32();\n  var data = this.readBytes(length);\n  return {\n    id: id,\n    length: length,\n    data: data\n  };\n};\n\nmodule.exports = parseMidi;","map":null,"metadata":{},"sourceType":"module"}
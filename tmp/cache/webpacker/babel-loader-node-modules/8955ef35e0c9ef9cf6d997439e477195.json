{"ast":null,"code":"/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n *\n * Parse the internal MP4 structure into an equivalent javascript\n * object.\n */\n'use strict';\n\nvar inspectMp4,\n    _textifyMp,\n    toUnsigned = require('../utils/bin').toUnsigned,\n    parseMp4Date = function parseMp4Date(seconds) {\n  return new Date(seconds * 1000 - 2082844800000);\n},\n    parseSampleFlags = function parseSampleFlags(flags) {\n  return {\n    isLeading: (flags[0] & 0x0c) >>> 2,\n    dependsOn: flags[0] & 0x03,\n    isDependedOn: (flags[1] & 0xc0) >>> 6,\n    hasRedundancy: (flags[1] & 0x30) >>> 4,\n    paddingValue: (flags[1] & 0x0e) >>> 1,\n    isNonSyncSample: flags[1] & 0x01,\n    degradationPriority: flags[2] << 8 | flags[3]\n  };\n},\n\n/**\n * Returns the string representation of an ASCII encoded four byte buffer.\n * @param buffer {Uint8Array} a four-byte buffer to translate\n * @return {string} the corresponding string\n */\nparseType = function parseType(buffer) {\n  var result = '';\n  result += String.fromCharCode(buffer[0]);\n  result += String.fromCharCode(buffer[1]);\n  result += String.fromCharCode(buffer[2]);\n  result += String.fromCharCode(buffer[3]);\n  return result;\n},\n    // Find the data for a box specified by its path\nfindBox = function findBox(data, path) {\n  var results = [],\n      i,\n      size,\n      type,\n      end,\n      subresults;\n\n  if (!path.length) {\n    // short-circuit the search for empty paths\n    return null;\n  }\n\n  for (i = 0; i < data.byteLength;) {\n    size = toUnsigned(data[i] << 24 | data[i + 1] << 16 | data[i + 2] << 8 | data[i + 3]);\n    type = parseType(data.subarray(i + 4, i + 8));\n    end = size > 1 ? i + size : data.byteLength;\n\n    if (type === path[0]) {\n      if (path.length === 1) {\n        // this is the end of the path and we've found the box we were\n        // looking for\n        results.push(data.subarray(i + 8, end));\n      } else {\n        // recursively search for the next box along the path\n        subresults = findBox(data.subarray(i + 8, end), path.slice(1));\n\n        if (subresults.length) {\n          results = results.concat(subresults);\n        }\n      }\n    }\n\n    i = end;\n  } // we've finished searching all of data\n\n\n  return results;\n},\n    nalParse = function nalParse(avcStream) {\n  var avcView = new DataView(avcStream.buffer, avcStream.byteOffset, avcStream.byteLength),\n      result = [],\n      i,\n      length;\n\n  for (i = 0; i + 4 < avcStream.length; i += length) {\n    length = avcView.getUint32(i);\n    i += 4; // bail if this doesn't appear to be an H264 stream\n\n    if (length <= 0) {\n      result.push('<span style=\\'color:red;\\'>MALFORMED DATA</span>');\n      continue;\n    }\n\n    switch (avcStream[i] & 0x1F) {\n      case 0x01:\n        result.push('slice_layer_without_partitioning_rbsp');\n        break;\n\n      case 0x05:\n        result.push('slice_layer_without_partitioning_rbsp_idr');\n        break;\n\n      case 0x06:\n        result.push('sei_rbsp');\n        break;\n\n      case 0x07:\n        result.push('seq_parameter_set_rbsp');\n        break;\n\n      case 0x08:\n        result.push('pic_parameter_set_rbsp');\n        break;\n\n      case 0x09:\n        result.push('access_unit_delimiter_rbsp');\n        break;\n\n      default:\n        result.push('UNKNOWN NAL - ' + avcStream[i] & 0x1F);\n        break;\n    }\n  }\n\n  return result;\n},\n    // registry of handlers for individual mp4 box types\nparse = {\n  // codingname, not a first-class box type. stsd entries share the\n  // same format as real boxes so the parsing infrastructure can be\n  // shared\n  avc1: function avc1(data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n    return {\n      dataReferenceIndex: view.getUint16(6),\n      width: view.getUint16(24),\n      height: view.getUint16(26),\n      horizresolution: view.getUint16(28) + view.getUint16(30) / 16,\n      vertresolution: view.getUint16(32) + view.getUint16(34) / 16,\n      frameCount: view.getUint16(40),\n      depth: view.getUint16(74),\n      config: inspectMp4(data.subarray(78, data.byteLength))\n    };\n  },\n  avcC: function avcC(data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        result = {\n      configurationVersion: data[0],\n      avcProfileIndication: data[1],\n      profileCompatibility: data[2],\n      avcLevelIndication: data[3],\n      lengthSizeMinusOne: data[4] & 0x03,\n      sps: [],\n      pps: []\n    },\n        numOfSequenceParameterSets = data[5] & 0x1f,\n        numOfPictureParameterSets,\n        nalSize,\n        offset,\n        i; // iterate past any SPSs\n\n    offset = 6;\n\n    for (i = 0; i < numOfSequenceParameterSets; i++) {\n      nalSize = view.getUint16(offset);\n      offset += 2;\n      result.sps.push(new Uint8Array(data.subarray(offset, offset + nalSize)));\n      offset += nalSize;\n    } // iterate past any PPSs\n\n\n    numOfPictureParameterSets = data[offset];\n    offset++;\n\n    for (i = 0; i < numOfPictureParameterSets; i++) {\n      nalSize = view.getUint16(offset);\n      offset += 2;\n      result.pps.push(new Uint8Array(data.subarray(offset, offset + nalSize)));\n      offset += nalSize;\n    }\n\n    return result;\n  },\n  btrt: function btrt(data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n    return {\n      bufferSizeDB: view.getUint32(0),\n      maxBitrate: view.getUint32(4),\n      avgBitrate: view.getUint32(8)\n    };\n  },\n  esds: function esds(data) {\n    return {\n      version: data[0],\n      flags: new Uint8Array(data.subarray(1, 4)),\n      esId: data[6] << 8 | data[7],\n      streamPriority: data[8] & 0x1f,\n      decoderConfig: {\n        objectProfileIndication: data[11],\n        streamType: data[12] >>> 2 & 0x3f,\n        bufferSize: data[13] << 16 | data[14] << 8 | data[15],\n        maxBitrate: data[16] << 24 | data[17] << 16 | data[18] << 8 | data[19],\n        avgBitrate: data[20] << 24 | data[21] << 16 | data[22] << 8 | data[23],\n        decoderConfigDescriptor: {\n          tag: data[24],\n          length: data[25],\n          audioObjectType: data[26] >>> 3 & 0x1f,\n          samplingFrequencyIndex: (data[26] & 0x07) << 1 | data[27] >>> 7 & 0x01,\n          channelConfiguration: data[27] >>> 3 & 0x0f\n        }\n      }\n    };\n  },\n  ftyp: function ftyp(data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        result = {\n      majorBrand: parseType(data.subarray(0, 4)),\n      minorVersion: view.getUint32(4),\n      compatibleBrands: []\n    },\n        i = 8;\n\n    while (i < data.byteLength) {\n      result.compatibleBrands.push(parseType(data.subarray(i, i + 4)));\n      i += 4;\n    }\n\n    return result;\n  },\n  dinf: function dinf(data) {\n    return {\n      boxes: inspectMp4(data)\n    };\n  },\n  dref: function dref(data) {\n    return {\n      version: data[0],\n      flags: new Uint8Array(data.subarray(1, 4)),\n      dataReferences: inspectMp4(data.subarray(8))\n    };\n  },\n  hdlr: function hdlr(data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        result = {\n      version: view.getUint8(0),\n      flags: new Uint8Array(data.subarray(1, 4)),\n      handlerType: parseType(data.subarray(8, 12)),\n      name: ''\n    },\n        i = 8; // parse out the name field\n\n    for (i = 24; i < data.byteLength; i++) {\n      if (data[i] === 0x00) {\n        // the name field is null-terminated\n        i++;\n        break;\n      }\n\n      result.name += String.fromCharCode(data[i]);\n    } // decode UTF-8 to javascript's internal representation\n    // see http://ecmanaut.blogspot.com/2006/07/encoding-decoding-utf8-in-javascript.html\n\n\n    result.name = decodeURIComponent(escape(result.name));\n    return result;\n  },\n  mdat: function mdat(data) {\n    return {\n      byteLength: data.byteLength,\n      nals: nalParse(data)\n    };\n  },\n  mdhd: function mdhd(data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        i = 4,\n        language,\n        result = {\n      version: view.getUint8(0),\n      flags: new Uint8Array(data.subarray(1, 4)),\n      language: ''\n    };\n\n    if (result.version === 1) {\n      i += 4;\n      result.creationTime = parseMp4Date(view.getUint32(i)); // truncating top 4 bytes\n\n      i += 8;\n      result.modificationTime = parseMp4Date(view.getUint32(i)); // truncating top 4 bytes\n\n      i += 4;\n      result.timescale = view.getUint32(i);\n      i += 8;\n      result.duration = view.getUint32(i); // truncating top 4 bytes\n    } else {\n      result.creationTime = parseMp4Date(view.getUint32(i));\n      i += 4;\n      result.modificationTime = parseMp4Date(view.getUint32(i));\n      i += 4;\n      result.timescale = view.getUint32(i);\n      i += 4;\n      result.duration = view.getUint32(i);\n    }\n\n    i += 4; // language is stored as an ISO-639-2/T code in an array of three 5-bit fields\n    // each field is the packed difference between its ASCII value and 0x60\n\n    language = view.getUint16(i);\n    result.language += String.fromCharCode((language >> 10) + 0x60);\n    result.language += String.fromCharCode(((language & 0x03e0) >> 5) + 0x60);\n    result.language += String.fromCharCode((language & 0x1f) + 0x60);\n    return result;\n  },\n  mdia: function mdia(data) {\n    return {\n      boxes: inspectMp4(data)\n    };\n  },\n  mfhd: function mfhd(data) {\n    return {\n      version: data[0],\n      flags: new Uint8Array(data.subarray(1, 4)),\n      sequenceNumber: data[4] << 24 | data[5] << 16 | data[6] << 8 | data[7]\n    };\n  },\n  minf: function minf(data) {\n    return {\n      boxes: inspectMp4(data)\n    };\n  },\n  // codingname, not a first-class box type. stsd entries share the\n  // same format as real boxes so the parsing infrastructure can be\n  // shared\n  mp4a: function mp4a(data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        result = {\n      // 6 bytes reserved\n      dataReferenceIndex: view.getUint16(6),\n      // 4 + 4 bytes reserved\n      channelcount: view.getUint16(16),\n      samplesize: view.getUint16(18),\n      // 2 bytes pre_defined\n      // 2 bytes reserved\n      samplerate: view.getUint16(24) + view.getUint16(26) / 65536\n    }; // if there are more bytes to process, assume this is an ISO/IEC\n    // 14496-14 MP4AudioSampleEntry and parse the ESDBox\n\n    if (data.byteLength > 28) {\n      result.streamDescriptor = inspectMp4(data.subarray(28))[0];\n    }\n\n    return result;\n  },\n  moof: function moof(data) {\n    return {\n      boxes: inspectMp4(data)\n    };\n  },\n  moov: function moov(data) {\n    return {\n      boxes: inspectMp4(data)\n    };\n  },\n  mvex: function mvex(data) {\n    return {\n      boxes: inspectMp4(data)\n    };\n  },\n  mvhd: function mvhd(data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        i = 4,\n        result = {\n      version: view.getUint8(0),\n      flags: new Uint8Array(data.subarray(1, 4))\n    };\n\n    if (result.version === 1) {\n      i += 4;\n      result.creationTime = parseMp4Date(view.getUint32(i)); // truncating top 4 bytes\n\n      i += 8;\n      result.modificationTime = parseMp4Date(view.getUint32(i)); // truncating top 4 bytes\n\n      i += 4;\n      result.timescale = view.getUint32(i);\n      i += 8;\n      result.duration = view.getUint32(i); // truncating top 4 bytes\n    } else {\n      result.creationTime = parseMp4Date(view.getUint32(i));\n      i += 4;\n      result.modificationTime = parseMp4Date(view.getUint32(i));\n      i += 4;\n      result.timescale = view.getUint32(i);\n      i += 4;\n      result.duration = view.getUint32(i);\n    }\n\n    i += 4; // convert fixed-point, base 16 back to a number\n\n    result.rate = view.getUint16(i) + view.getUint16(i + 2) / 16;\n    i += 4;\n    result.volume = view.getUint8(i) + view.getUint8(i + 1) / 8;\n    i += 2;\n    i += 2;\n    i += 2 * 4;\n    result.matrix = new Uint32Array(data.subarray(i, i + 9 * 4));\n    i += 9 * 4;\n    i += 6 * 4;\n    result.nextTrackId = view.getUint32(i);\n    return result;\n  },\n  pdin: function pdin(data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n    return {\n      version: view.getUint8(0),\n      flags: new Uint8Array(data.subarray(1, 4)),\n      rate: view.getUint32(4),\n      initialDelay: view.getUint32(8)\n    };\n  },\n  sdtp: function sdtp(data) {\n    var result = {\n      version: data[0],\n      flags: new Uint8Array(data.subarray(1, 4)),\n      samples: []\n    },\n        i;\n\n    for (i = 4; i < data.byteLength; i++) {\n      result.samples.push({\n        dependsOn: (data[i] & 0x30) >> 4,\n        isDependedOn: (data[i] & 0x0c) >> 2,\n        hasRedundancy: data[i] & 0x03\n      });\n    }\n\n    return result;\n  },\n  sidx: function sidx(data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        result = {\n      version: data[0],\n      flags: new Uint8Array(data.subarray(1, 4)),\n      references: [],\n      referenceId: view.getUint32(4),\n      timescale: view.getUint32(8),\n      earliestPresentationTime: view.getUint32(12),\n      firstOffset: view.getUint32(16)\n    },\n        referenceCount = view.getUint16(22),\n        i;\n\n    for (i = 24; referenceCount; i += 12, referenceCount--) {\n      result.references.push({\n        referenceType: (data[i] & 0x80) >>> 7,\n        referencedSize: view.getUint32(i) & 0x7FFFFFFF,\n        subsegmentDuration: view.getUint32(i + 4),\n        startsWithSap: !!(data[i + 8] & 0x80),\n        sapType: (data[i + 8] & 0x70) >>> 4,\n        sapDeltaTime: view.getUint32(i + 8) & 0x0FFFFFFF\n      });\n    }\n\n    return result;\n  },\n  smhd: function smhd(data) {\n    return {\n      version: data[0],\n      flags: new Uint8Array(data.subarray(1, 4)),\n      balance: data[4] + data[5] / 256\n    };\n  },\n  stbl: function stbl(data) {\n    return {\n      boxes: inspectMp4(data)\n    };\n  },\n  stco: function stco(data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        result = {\n      version: data[0],\n      flags: new Uint8Array(data.subarray(1, 4)),\n      chunkOffsets: []\n    },\n        entryCount = view.getUint32(4),\n        i;\n\n    for (i = 8; entryCount; i += 4, entryCount--) {\n      result.chunkOffsets.push(view.getUint32(i));\n    }\n\n    return result;\n  },\n  stsc: function stsc(data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        entryCount = view.getUint32(4),\n        result = {\n      version: data[0],\n      flags: new Uint8Array(data.subarray(1, 4)),\n      sampleToChunks: []\n    },\n        i;\n\n    for (i = 8; entryCount; i += 12, entryCount--) {\n      result.sampleToChunks.push({\n        firstChunk: view.getUint32(i),\n        samplesPerChunk: view.getUint32(i + 4),\n        sampleDescriptionIndex: view.getUint32(i + 8)\n      });\n    }\n\n    return result;\n  },\n  stsd: function stsd(data) {\n    return {\n      version: data[0],\n      flags: new Uint8Array(data.subarray(1, 4)),\n      sampleDescriptions: inspectMp4(data.subarray(8))\n    };\n  },\n  stsz: function stsz(data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        result = {\n      version: data[0],\n      flags: new Uint8Array(data.subarray(1, 4)),\n      sampleSize: view.getUint32(4),\n      entries: []\n    },\n        i;\n\n    for (i = 12; i < data.byteLength; i += 4) {\n      result.entries.push(view.getUint32(i));\n    }\n\n    return result;\n  },\n  stts: function stts(data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        result = {\n      version: data[0],\n      flags: new Uint8Array(data.subarray(1, 4)),\n      timeToSamples: []\n    },\n        entryCount = view.getUint32(4),\n        i;\n\n    for (i = 8; entryCount; i += 8, entryCount--) {\n      result.timeToSamples.push({\n        sampleCount: view.getUint32(i),\n        sampleDelta: view.getUint32(i + 4)\n      });\n    }\n\n    return result;\n  },\n  styp: function styp(data) {\n    return parse.ftyp(data);\n  },\n  tfdt: function tfdt(data) {\n    var result = {\n      version: data[0],\n      flags: new Uint8Array(data.subarray(1, 4)),\n      baseMediaDecodeTime: toUnsigned(data[4] << 24 | data[5] << 16 | data[6] << 8 | data[7])\n    };\n\n    if (result.version === 1) {\n      result.baseMediaDecodeTime *= Math.pow(2, 32);\n      result.baseMediaDecodeTime += toUnsigned(data[8] << 24 | data[9] << 16 | data[10] << 8 | data[11]);\n    }\n\n    return result;\n  },\n  tfhd: function tfhd(data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        result = {\n      version: data[0],\n      flags: new Uint8Array(data.subarray(1, 4)),\n      trackId: view.getUint32(4)\n    },\n        baseDataOffsetPresent = result.flags[2] & 0x01,\n        sampleDescriptionIndexPresent = result.flags[2] & 0x02,\n        defaultSampleDurationPresent = result.flags[2] & 0x08,\n        defaultSampleSizePresent = result.flags[2] & 0x10,\n        defaultSampleFlagsPresent = result.flags[2] & 0x20,\n        durationIsEmpty = result.flags[0] & 0x010000,\n        defaultBaseIsMoof = result.flags[0] & 0x020000,\n        i;\n    i = 8;\n\n    if (baseDataOffsetPresent) {\n      i += 4; // truncate top 4 bytes\n      // FIXME: should we read the full 64 bits?\n\n      result.baseDataOffset = view.getUint32(12);\n      i += 4;\n    }\n\n    if (sampleDescriptionIndexPresent) {\n      result.sampleDescriptionIndex = view.getUint32(i);\n      i += 4;\n    }\n\n    if (defaultSampleDurationPresent) {\n      result.defaultSampleDuration = view.getUint32(i);\n      i += 4;\n    }\n\n    if (defaultSampleSizePresent) {\n      result.defaultSampleSize = view.getUint32(i);\n      i += 4;\n    }\n\n    if (defaultSampleFlagsPresent) {\n      result.defaultSampleFlags = view.getUint32(i);\n    }\n\n    if (durationIsEmpty) {\n      result.durationIsEmpty = true;\n    }\n\n    if (!baseDataOffsetPresent && defaultBaseIsMoof) {\n      result.baseDataOffsetIsMoof = true;\n    }\n\n    return result;\n  },\n  tkhd: function tkhd(data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        i = 4,\n        result = {\n      version: view.getUint8(0),\n      flags: new Uint8Array(data.subarray(1, 4))\n    };\n\n    if (result.version === 1) {\n      i += 4;\n      result.creationTime = parseMp4Date(view.getUint32(i)); // truncating top 4 bytes\n\n      i += 8;\n      result.modificationTime = parseMp4Date(view.getUint32(i)); // truncating top 4 bytes\n\n      i += 4;\n      result.trackId = view.getUint32(i);\n      i += 4;\n      i += 8;\n      result.duration = view.getUint32(i); // truncating top 4 bytes\n    } else {\n      result.creationTime = parseMp4Date(view.getUint32(i));\n      i += 4;\n      result.modificationTime = parseMp4Date(view.getUint32(i));\n      i += 4;\n      result.trackId = view.getUint32(i);\n      i += 4;\n      i += 4;\n      result.duration = view.getUint32(i);\n    }\n\n    i += 4;\n    i += 2 * 4;\n    result.layer = view.getUint16(i);\n    i += 2;\n    result.alternateGroup = view.getUint16(i);\n    i += 2; // convert fixed-point, base 16 back to a number\n\n    result.volume = view.getUint8(i) + view.getUint8(i + 1) / 8;\n    i += 2;\n    i += 2;\n    result.matrix = new Uint32Array(data.subarray(i, i + 9 * 4));\n    i += 9 * 4;\n    result.width = view.getUint16(i) + view.getUint16(i + 2) / 16;\n    i += 4;\n    result.height = view.getUint16(i) + view.getUint16(i + 2) / 16;\n    return result;\n  },\n  traf: function traf(data) {\n    return {\n      boxes: inspectMp4(data)\n    };\n  },\n  trak: function trak(data) {\n    return {\n      boxes: inspectMp4(data)\n    };\n  },\n  trex: function trex(data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n    return {\n      version: data[0],\n      flags: new Uint8Array(data.subarray(1, 4)),\n      trackId: view.getUint32(4),\n      defaultSampleDescriptionIndex: view.getUint32(8),\n      defaultSampleDuration: view.getUint32(12),\n      defaultSampleSize: view.getUint32(16),\n      sampleDependsOn: data[20] & 0x03,\n      sampleIsDependedOn: (data[21] & 0xc0) >> 6,\n      sampleHasRedundancy: (data[21] & 0x30) >> 4,\n      samplePaddingValue: (data[21] & 0x0e) >> 1,\n      sampleIsDifferenceSample: !!(data[21] & 0x01),\n      sampleDegradationPriority: view.getUint16(22)\n    };\n  },\n  trun: function trun(data) {\n    var result = {\n      version: data[0],\n      flags: new Uint8Array(data.subarray(1, 4)),\n      samples: []\n    },\n        view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        // Flag interpretation\n    dataOffsetPresent = result.flags[2] & 0x01,\n        // compare with 2nd byte of 0x1\n    firstSampleFlagsPresent = result.flags[2] & 0x04,\n        // compare with 2nd byte of 0x4\n    sampleDurationPresent = result.flags[1] & 0x01,\n        // compare with 2nd byte of 0x100\n    sampleSizePresent = result.flags[1] & 0x02,\n        // compare with 2nd byte of 0x200\n    sampleFlagsPresent = result.flags[1] & 0x04,\n        // compare with 2nd byte of 0x400\n    sampleCompositionTimeOffsetPresent = result.flags[1] & 0x08,\n        // compare with 2nd byte of 0x800\n    sampleCount = view.getUint32(4),\n        offset = 8,\n        sample;\n\n    if (dataOffsetPresent) {\n      // 32 bit signed integer\n      result.dataOffset = view.getInt32(offset);\n      offset += 4;\n    } // Overrides the flags for the first sample only. The order of\n    // optional values will be: duration, size, compositionTimeOffset\n\n\n    if (firstSampleFlagsPresent && sampleCount) {\n      sample = {\n        flags: parseSampleFlags(data.subarray(offset, offset + 4))\n      };\n      offset += 4;\n\n      if (sampleDurationPresent) {\n        sample.duration = view.getUint32(offset);\n        offset += 4;\n      }\n\n      if (sampleSizePresent) {\n        sample.size = view.getUint32(offset);\n        offset += 4;\n      }\n\n      if (sampleCompositionTimeOffsetPresent) {\n        // Note: this should be a signed int if version is 1\n        sample.compositionTimeOffset = view.getUint32(offset);\n        offset += 4;\n      }\n\n      result.samples.push(sample);\n      sampleCount--;\n    }\n\n    while (sampleCount--) {\n      sample = {};\n\n      if (sampleDurationPresent) {\n        sample.duration = view.getUint32(offset);\n        offset += 4;\n      }\n\n      if (sampleSizePresent) {\n        sample.size = view.getUint32(offset);\n        offset += 4;\n      }\n\n      if (sampleFlagsPresent) {\n        sample.flags = parseSampleFlags(data.subarray(offset, offset + 4));\n        offset += 4;\n      }\n\n      if (sampleCompositionTimeOffsetPresent) {\n        // Note: this should be a signed int if version is 1\n        sample.compositionTimeOffset = view.getUint32(offset);\n        offset += 4;\n      }\n\n      result.samples.push(sample);\n    }\n\n    return result;\n  },\n  'url ': function url(data) {\n    return {\n      version: data[0],\n      flags: new Uint8Array(data.subarray(1, 4))\n    };\n  },\n  vmhd: function vmhd(data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n    return {\n      version: data[0],\n      flags: new Uint8Array(data.subarray(1, 4)),\n      graphicsmode: view.getUint16(4),\n      opcolor: new Uint16Array([view.getUint16(6), view.getUint16(8), view.getUint16(10)])\n    };\n  }\n};\n/**\n * Return a javascript array of box objects parsed from an ISO base\n * media file.\n * @param data {Uint8Array} the binary data of the media to be inspected\n * @return {array} a javascript array of potentially nested box objects\n */\n\n\ninspectMp4 = function inspectMp4(data) {\n  var i = 0,\n      result = [],\n      view,\n      size,\n      type,\n      end,\n      box; // Convert data from Uint8Array to ArrayBuffer, to follow Dataview API\n\n  var ab = new ArrayBuffer(data.length);\n  var v = new Uint8Array(ab);\n\n  for (var z = 0; z < data.length; ++z) {\n    v[z] = data[z];\n  }\n\n  view = new DataView(ab);\n\n  while (i < data.byteLength) {\n    // parse box data\n    size = view.getUint32(i);\n    type = parseType(data.subarray(i + 4, i + 8));\n    end = size > 1 ? i + size : data.byteLength; // parse type-specific data\n\n    box = (parse[type] || function (data) {\n      return {\n        data: data\n      };\n    })(data.subarray(i + 8, end));\n\n    box.size = size;\n    box.type = type; // store this box and move to the next\n\n    result.push(box);\n    i = end;\n  }\n\n  return result;\n};\n/**\n * Returns a textual representation of the javascript represtentation\n * of an MP4 file. You can use it as an alternative to\n * JSON.stringify() to compare inspected MP4s.\n * @param inspectedMp4 {array} the parsed array of boxes in an MP4\n * file\n * @param depth {number} (optional) the number of ancestor boxes of\n * the elements of inspectedMp4. Assumed to be zero if unspecified.\n * @return {string} a text representation of the parsed MP4\n */\n\n\n_textifyMp = function textifyMp4(inspectedMp4, depth) {\n  var indent;\n  depth = depth || 0;\n  indent = new Array(depth * 2 + 1).join(' '); // iterate over all the boxes\n\n  return inspectedMp4.map(function (box, index) {\n    // list the box type first at the current indentation level\n    return indent + box.type + '\\n' + // the type is already included and handle child boxes separately\n    Object.keys(box).filter(function (key) {\n      return key !== 'type' && key !== 'boxes'; // output all the box properties\n    }).map(function (key) {\n      var prefix = indent + '  ' + key + ': ',\n          value = box[key]; // print out raw bytes as hexademical\n\n      if (value instanceof Uint8Array || value instanceof Uint32Array) {\n        var bytes = Array.prototype.slice.call(new Uint8Array(value.buffer, value.byteOffset, value.byteLength)).map(function (_byte) {\n          return ' ' + ('00' + _byte.toString(16)).slice(-2);\n        }).join('').match(/.{1,24}/g);\n\n        if (!bytes) {\n          return prefix + '<>';\n        }\n\n        if (bytes.length === 1) {\n          return prefix + '<' + bytes.join('').slice(1) + '>';\n        }\n\n        return prefix + '<\\n' + bytes.map(function (line) {\n          return indent + '  ' + line;\n        }).join('\\n') + '\\n' + indent + '  >';\n      } // stringify generic objects\n\n\n      return prefix + JSON.stringify(value, null, 2).split('\\n').map(function (line, index) {\n        if (index === 0) {\n          return line;\n        }\n\n        return indent + '  ' + line;\n      }).join('\\n');\n    }).join('\\n') + ( // recursively textify the child boxes\n    box.boxes ? '\\n' + _textifyMp(box.boxes, depth + 1) : '');\n  }).join('\\n');\n};\n\nmodule.exports = {\n  inspect: inspectMp4,\n  textify: _textifyMp,\n  parseType: parseType,\n  findBox: findBox,\n  parseTraf: parse.traf,\n  parseTfdt: parse.tfdt,\n  parseHdlr: parse.hdlr,\n  parseTfhd: parse.tfhd,\n  parseTrun: parse.trun,\n  parseSidx: parse.sidx\n};","map":null,"metadata":{},"sourceType":"module"}
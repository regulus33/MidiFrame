{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nimport { Controller } from \"stimulus\";\nimport WebMidi from 'webmidi';\nimport { toTheNearestThousandth } from '../../helpers/math';\n\nvar _default = /*#__PURE__*/function (_Controller) {\n  _inherits(_default, _Controller);\n\n  var _super = _createSuper(_default);\n\n  function _default() {\n    _classCallCheck(this, _default);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(_default, [{\n    key: \"connect\",\n    value: function connect() {\n      this.recording = false;\n\n      this._enable_midi();\n\n      this.midiEvents = [];\n      this.clockSignalsPassedSinceRecordStart = 0;\n      this.animateProgressBar = this.animateProgressBar.bind(this);\n    }\n  }, {\n    key: \"onMessageClock\",\n    value: function onMessageClock(message) {\n      // ? only count clock signals if recording \n      if (this._recording) {\n        console.log(this.clockSignalsPassedSinceRecordStart);\n        console.log(message);\n        this.clockSignalsPassedSinceRecordStart++; // console.log(`clock signal passed: ${this.clockSignalsPassedSinceRecordStart} total clock signals: ${this._totaClockSignals}`)\n\n        switch (this.clockSignalsPassedSinceRecordStart) {\n          // ! end is reached! exit recording loop\n          case this._totaClockSignals:\n            this._addStopTime(message.timestamp);\n\n            this._recording = false;\n\n            this._resetClock();\n\n            this.toggleRecordingSession();\n            break;\n        }\n      }\n    } //? this method adds the starting timestamp (its the most precise way)\n    //? and begins adding new midi events to the collection  \n\n  }, {\n    key: \"onMessageStart\",\n    value: function onMessageStart(msg) {\n      if (this._recordingSessionOpen) {\n        window.requestAnimationFrame(this.animateProgressBar);\n\n        this._addStartEvent(msg.timestamp);\n\n        this._startRecordingMidiNotes();\n      }\n    }\n  }, {\n    key: \"getSavedChannel\",\n    value: function getSavedChannel() {\n      return Number(this.element.getAttribute('data-midi-recorder-channel'));\n    }\n  }, {\n    key: \"toggleRecordingSession\",\n    value: function toggleRecordingSession() {\n      this._recordingSessionOpen = !this._recordingSessionOpen;\n      M.toast({\n        html: \"recording session \".concat(this._recordingSessionOpen ? 'open' : 'closed')\n      });\n    }\n  }, {\n    key: \"_resetClock\",\n    value: function _resetClock() {\n      this.clockSignalsPassedSinceRecordStart = 0;\n    }\n  }, {\n    key: \"_startRecordingMidiNotes\",\n    value: function _startRecordingMidiNotes() {\n      this._recording = true;\n    }\n  }, {\n    key: \"_numericalValue\",\n    value: function _numericalValue(str) {\n      return toTheNearestThousandth(parseFloat(str));\n    } // ? RECORDING SESSION \n\n  }, {\n    key: \"_enable_midi\",\n    //////////////////////////////////////////\n    /// WEB MIDI SETUP:                     //\n    //////////////////////////////////////////\n    // requests access from browser, only runs if access is enabled \n    value: function _enable_midi() {\n      var _this = this;\n\n      WebMidi.enable(function (error) {\n        error ? _this._on_error(error) : _this._on_success(_this.getSavedChannel());\n      });\n    }\n  }, {\n    key: \"_on_error\",\n    value: function _on_error(error) {\n      alert(error);\n    }\n  }, {\n    key: \"resetMidiListeners\",\n    value: function resetMidiListeners(channel) {\n      this._wipeListeners();\n\n      this._on_success(channel);\n\n      console.log(\"reset all recorder listeners for channel \".concat(channel));\n    } // not necessary to wipe clock and start since they will always remain the same on 'all'\n\n  }, {\n    key: \"_wipeListeners\",\n    value: function _wipeListeners() {\n      if (this._midiInput) {\n        this._midiInput.removeListener('noteon');\n      }\n    }\n  }, {\n    key: \"_on_success\",\n    value: function _on_success(channel) {\n      console.log(\"setting listeners for channel: \" + channel); // ? just for knowing if midi is being received or not\n\n      if (this._midiInput) {\n        this._midiInput.addListener('clock', \"all\", this.onMessageClock.bind(this));\n\n        this._midiInput.addListener('start', \"all\", this.onMessageStart.bind(this));\n\n        this._midiInput.addListener('noteon', channel, this.addMidiEvent.bind(this));\n      }\n    }\n  }, {\n    key: \"_getPatternId\",\n    value: function _getPatternId() {\n      return this.patternIdTarget.getAttribute(\"pattern-id\");\n    }\n  }, {\n    key: \"_getProjectId\",\n    value: function _getProjectId() {\n      return this.projectIdTarget.getAttribute(\"project-id\");\n    }\n  }, {\n    key: \"_stopMidi\",\n    value: function _stopMidi() {\n      this._midiOutput.sendStop();\n    }\n  }, {\n    key: \"_addStartEvent\",\n    value: function _addStartEvent(timestamp) {\n      // ? on first clock signal of recording session we get the received time of the \n      // ? first note \n      var processeableEvent = {\n        note: \"start\",\n        timestamp: timestamp\n      };\n      this.midiEvents.push(processeableEvent);\n    }\n  }, {\n    key: \"_addStopTime\",\n    value: function _addStopTime(timestamp) {\n      var processeableEvent = {\n        note: \"stop\",\n        timestamp: timestamp\n      };\n      this.midiEvents.push(processeableEvent);\n    }\n  }, {\n    key: \"addMidiEvent\",\n    value: function addMidiEvent(event) {\n      var calibratedTimeStamp; // ? first you need to get the amount of time to subtract from each timestamp so that the first evetn starts at 0:00\n      // ? set the timing in the new event  \n\n      if (this._recording) {\n        var processeableEvent = {\n          note: event.note.number,\n          timestamp: event.timestamp\n        };\n        this.midiEvents.push(processeableEvent);\n      }\n    } // recursively request to execute this dom update before each paint (or frame)\n    // 60 fps \n\n  }, {\n    key: \"animateProgressBar\",\n    value: function animateProgressBar() {\n      if (this.recording) {\n        var percent = \"\".concat(this.clockSignalsPassedSinceRecordStart / this._totaClockSignals * 100, \"%\");\n        this.progressBarTarget.style.width = percent;\n        console.log(percent);\n        console.log(this.clockSignalsPassedSinceRecordStart);\n        window.requestAnimationFrame(this.animateProgressBar);\n      }\n    } // **************************************************************\n    // ******************* GETTERS AND SETTERS **********************\n    // **************************************************************\n    // ? CHANNEL\n    // ? we get it from the document, it is save in the pattern \n    ///////////////////////////////////////////////////////////////////\n\n  }, {\n    key: \"_recordingSessionOpen\",\n    get: function get() {\n      return this.recordingSessionOpen;\n    },\n    set: function set(isOpen) {\n      this.recordingSessionOpen = isOpen;\n      this.recordButtonTarget.classList.toggle('open-recording-session');\n    }\n  }, {\n    key: \"_channel\",\n    get: function get() {\n      return parseInt(this.channelTarget.getAttribute('device-channel'));\n    } /////////////////////////\n\n  }, {\n    key: \"_midiInput\",\n    get: function get() {\n      return WebMidi.inputs[0];\n    }\n  }, {\n    key: \"_midiOutput\",\n    get: function get() {\n      return WebMidi.outputs[0];\n    }\n  }, {\n    key: \"_recording\",\n    get: function get() {\n      return this.recording;\n    } // ? set recording AND also stop or start midi based on value of 'recording'\n    ,\n    set: function set(recording) {\n      if (recording) {\n        this.recording = true;\n      } else {\n        this.recording = false;\n\n        this._stopMidi();\n      }\n    }\n  }, {\n    key: \"_totaClockSignals\",\n    get: function get() {\n      return parseInt(this.recordButtonTarget.getAttribute(\"data-midi-recorder-total-clock-signals\"));\n    }\n  }]);\n\n  return _default;\n}(Controller);\n\n_default.targets = [\"recordButton\", \"progressBar\"];\nexport { _default as default };","map":{"version":3,"sources":["/Users/zack/andrWert43h/app/javascript/controllers/patterns/midi_recorder_controller.js"],"names":["Controller","WebMidi","toTheNearestThousandth","recording","_enable_midi","midiEvents","clockSignalsPassedSinceRecordStart","animateProgressBar","bind","message","_recording","console","log","_totaClockSignals","_addStopTime","timestamp","_resetClock","toggleRecordingSession","msg","_recordingSessionOpen","window","requestAnimationFrame","_addStartEvent","_startRecordingMidiNotes","Number","element","getAttribute","M","toast","html","str","parseFloat","enable","error","_on_error","_on_success","getSavedChannel","alert","channel","_wipeListeners","_midiInput","removeListener","addListener","onMessageClock","onMessageStart","addMidiEvent","patternIdTarget","projectIdTarget","_midiOutput","sendStop","processeableEvent","note","push","event","calibratedTimeStamp","number","percent","progressBarTarget","style","width","recordingSessionOpen","isOpen","recordButtonTarget","classList","toggle","parseInt","channelTarget","inputs","outputs","_stopMidi","targets"],"mappings":"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","sourcesContent":["import { Controller } from \"stimulus\";\nimport WebMidi from 'webmidi';\nimport { toTheNearestThousandth} from '../../helpers/math';\n\nexport default class extends Controller {\n\n  static targets = [\n    \"recordButton\",\n    \"progressBar\"\n  ];\n\n  connect() {\n    this.recording = false; \n    this._enable_midi();\n    this.midiEvents = []; \n    this.clockSignalsPassedSinceRecordStart = 0; \n    this.animateProgressBar = this.animateProgressBar.bind(this);\n  }\n\n  onMessageClock(message) {\n    // ? only count clock signals if recording \n    if (this._recording) {\n      console.log(this.clockSignalsPassedSinceRecordStart);\n      console.log(message);\n      this.clockSignalsPassedSinceRecordStart++\n      // console.log(`clock signal passed: ${this.clockSignalsPassedSinceRecordStart} total clock signals: ${this._totaClockSignals}`)\n      switch (this.clockSignalsPassedSinceRecordStart) {\n        // ! end is reached! exit recording loop\n        case this._totaClockSignals:\n          this._addStopTime(message.timestamp);\n          this._recording = false;\n          this._resetClock();\n          this.toggleRecordingSession();\n          break;\n      }\n    }\n  }\n\n  //? this method adds the starting timestamp (its the most precise way)\n  //? and begins adding new midi events to the collection  \n  onMessageStart(msg) {\n    if (this._recordingSessionOpen) {\n      window.requestAnimationFrame(this.animateProgressBar);\n      this._addStartEvent(msg.timestamp);\n      this._startRecordingMidiNotes();\n    }\n  }\n\n  getSavedChannel(){\n    return Number(this.element.getAttribute('data-midi-recorder-channel'));\n  }\n\n  toggleRecordingSession() {\n    this._recordingSessionOpen = !this._recordingSessionOpen;\n    M.toast({ html: `recording session ${this._recordingSessionOpen ? 'open' : 'closed'}` });\n  }\n\n  _resetClock() {\n    this.clockSignalsPassedSinceRecordStart = 0;\n  }\n\n  _startRecordingMidiNotes() {\n    this._recording = true;\n  }\n\n  _numericalValue(str) {\n    return toTheNearestThousandth(parseFloat(str));\n  }\n\n  // ? RECORDING SESSION \n  get _recordingSessionOpen() {\n    return this.recordingSessionOpen;\n  }\n\n  set _recordingSessionOpen(isOpen) {\n    this.recordingSessionOpen = isOpen;\n    this.recordButtonTarget.classList.toggle('open-recording-session');\n  }\n\n  //////////////////////////////////////////\n  /// WEB MIDI SETUP:                     //\n  //////////////////////////////////////////\n  // requests access from browser, only runs if access is enabled \n  _enable_midi() {\n    WebMidi.enable(error => { error ? this._on_error(error) : this._on_success(this.getSavedChannel()) });\n  }\n\n  _on_error(error) {\n    alert(error);\n  }\n\n  resetMidiListeners(channel) {\n    this._wipeListeners();\n    this._on_success(channel);\n    console.log(`reset all recorder listeners for channel ${channel}`)\n  }\n\n  // not necessary to wipe clock and start since they will always remain the same on 'all'\n  _wipeListeners() {\n    if(this._midiInput){\n      this._midiInput.removeListener('noteon');\n    }\n  }\n\n  _on_success(channel) {\n    console.log(\"setting listeners for channel: \" + channel)\n    // ? just for knowing if midi is being received or not\n    if(this._midiInput){\n      this._midiInput.addListener('clock', \"all\", this.onMessageClock.bind(this));\n      this._midiInput.addListener('start', \"all\", this.onMessageStart.bind(this));\n      this._midiInput.addListener('noteon', channel, this.addMidiEvent.bind(this));\n    }\n  }\n\n  _getPatternId() {\n    return this.patternIdTarget.getAttribute(\"pattern-id\");\n  }\n\n  _getProjectId() {\n    return this.projectIdTarget.getAttribute(\"project-id\");\n  }\n\n  _stopMidi() {\n    this._midiOutput.sendStop();\n  }\n\n  _addStartEvent(timestamp) {\n    // ? on first clock signal of recording session we get the received time of the \n    // ? first note \n    let processeableEvent = { note: \"start\", timestamp: timestamp };\n    this.midiEvents.push(processeableEvent);\n  }\n\n  _addStopTime(timestamp) {\n    let processeableEvent = { note: \"stop\", timestamp: timestamp };\n    this.midiEvents.push(processeableEvent);\n  }   \n\n  addMidiEvent(event) {\n    let calibratedTimeStamp\n    // ? first you need to get the amount of time to subtract from each timestamp so that the first evetn starts at 0:00\n    // ? set the timing in the new event  \n    if (this._recording) {\n      let processeableEvent = { note: event.note.number, timestamp: event.timestamp };\n      this.midiEvents.push(processeableEvent);\n    }\n  }\n\n  // recursively request to execute this dom update before each paint (or frame)\n  // 60 fps \n  animateProgressBar(){\n    if(this.recording) {\n      let percent = `${(this.clockSignalsPassedSinceRecordStart/this._totaClockSignals)*100}%`;\n      this.progressBarTarget.style.width=percent;\n      console.log(percent);\n      console.log(this.clockSignalsPassedSinceRecordStart);\n      window.requestAnimationFrame(this.animateProgressBar);\n    }\n  }\n\n  // **************************************************************\n  // ******************* GETTERS AND SETTERS **********************\n  // **************************************************************\n\n  // ? CHANNEL\n  // ? we get it from the document, it is save in the pattern \n  ///////////////////////////////////////////////////////////////////\n  get _channel() {\n    return parseInt(this.channelTarget.getAttribute('device-channel'));\n  }\n/////////////////////////\n  get _midiInput() {\n    return WebMidi.inputs[0];\n  }\n\n  get _midiOutput() {\n    return WebMidi.outputs[0];\n  }\n\n  get _recording() {\n    return this.recording;\n  }\n  // ? set recording AND also stop or start midi based on value of 'recording'\n  set _recording(recording) {\n    if (recording) {\n      this.recording = true;\n    } else {\n      this.recording = false;\n      this._stopMidi();\n    }\n  }\n\n  get _totaClockSignals() {\n    return parseInt(this.recordButtonTarget.getAttribute(\"data-midi-recorder-total-clock-signals\"));\n  }\n\n}\n\n\n"]},"metadata":{},"sourceType":"module"}
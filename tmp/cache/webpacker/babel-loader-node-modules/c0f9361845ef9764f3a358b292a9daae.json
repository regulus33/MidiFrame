{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nimport { baseUrl } from \"./constants\";\nexport var patternsUrl = function patternsUrl(projectId, patternId) {\n  return \"\".concat(baseUrl, \"/projects/\").concat(projectId, \"/patterns/\").concat(patternId);\n};\nexport var patternGeneratorUrl = function patternGeneratorUrl(patternId, projectId) {\n  return \"\".concat(baseUrl, \"/pattern-generate/\").concat(patternId, \"/\").concat(projectId);\n};\nexport var autoTuneProjectUrl = function autoTuneProjectUrl(projectId) {\n  return \"\".concat(baseUrl, \"/autotune/\").concat(projectId);\n};\nexport var savePattern = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref) {\n    var channel, pianoData, pianoTextData, midiEvents, patternId, projectId, midiType, stepLength, requestBody, response;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            channel = _ref.channel, pianoData = _ref.pianoData, pianoTextData = _ref.pianoTextData, midiEvents = _ref.midiEvents, patternId = _ref.patternId, projectId = _ref.projectId, midiType = _ref.midiType, stepLength = _ref.stepLength;\n            // Default options are marked with * \n            console.log(\"[NETWORK] about to POST pattern data: channel: \".concat(channel, \", pianoData: \").concat(JSON.stringify(pianoData), \", pianoTextData: \").concat(JSON.stringify(pianoTextData), \", midiEvents: \").concat(JSON.stringify(midiEvents), \", patternId: \").concat(patternId, \", projectId: \").concat(projectId));\n            requestBody = {\n              midiEvents: midiEvents,\n              pianoData: pianoData,\n              channel: channel,\n              pianoTextData: pianoTextData,\n              stepLength: stepLength\n            };\n\n            if (midiType != undefined) {\n              requestBody['midiType'] = midiType;\n            }\n\n            _context.next = 6;\n            return fetch(patternsUrl(projectId, patternId), {\n              method: 'PUT',\n              headers: {\n                'Content-Type': 'application/json'\n              },\n              body: JSON.stringify(requestBody) // body data type must match \"Content-Type\" header\n\n            });\n\n          case 6:\n            response = _context.sent;\n            console.log(\"[NETWORK] got a response from server, response succeeded?: \".concat(response.ok));\n\n          case 8:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function savePattern(_x) {\n    return _ref2.apply(this, arguments);\n  };\n}(); // tunerArgs == {g: true, gs: false, c: true ...}\n// Returns response when done \n\nexport var autotuneProject = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(tunerArgs, projectId, token) {\n    var requestBody, response;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            requestBody = {\n              authenticity_token: token,\n              tuner_args: tunerArgs\n            };\n            _context2.next = 3;\n            return fetch(autoTuneProjectUrl(projectId), {\n              method: 'PUT',\n              headers: {\n                'Content-Type': 'application/json'\n              },\n              body: JSON.stringify(requestBody) // body data type must match \"Content-Type\" header\n\n            });\n\n          case 3:\n            response = _context2.sent;\n            return _context2.abrupt(\"return\", response);\n\n          case 5:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function autotuneProject(_x2, _x3, _x4) {\n    return _ref3.apply(this, arguments);\n  };\n}();\nexport var generatePatternClip = function generatePatternClip(_ref4) {\n  var patternId = _ref4.patternId,\n      projectId = _ref4.projectId;\n  console.log(patternId);\n  return fetch(patternGeneratorUrl(patternId, projectId), {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    }\n  });\n};","map":{"version":3,"sources":["/Users/zack/andrWert43h/app/javascript/helpers/network.js"],"names":["baseUrl","patternsUrl","projectId","patternId","patternGeneratorUrl","autoTuneProjectUrl","savePattern","channel","pianoData","pianoTextData","midiEvents","midiType","stepLength","console","log","JSON","stringify","requestBody","undefined","fetch","method","headers","body","response","ok","autotuneProject","tunerArgs","token","authenticity_token","tuner_args","generatePatternClip"],"mappings":"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","sourcesContent":["import { baseUrl } from \"./constants\";\n\nexport const patternsUrl = (projectId, patternId) => `${baseUrl}/projects/${projectId}/patterns/${patternId}`\nexport const patternGeneratorUrl = (patternId, projectId) => `${baseUrl}/pattern-generate/${patternId}/${projectId}`\nexport const autoTuneProjectUrl = (projectId) => `${baseUrl}/autotune/${projectId}`\n\nexport const savePattern = async ({ channel, pianoData, pianoTextData, midiEvents, patternId, projectId, midiType, stepLength }) => {\n  // Default options are marked with * \n  console.log(`[NETWORK] about to POST pattern data: channel: ${channel}, pianoData: ${JSON.stringify(pianoData)}, pianoTextData: ${JSON.stringify(pianoTextData)}, midiEvents: ${JSON.stringify(midiEvents)}, patternId: ${patternId}, projectId: ${projectId}`);\n  const requestBody = { midiEvents, pianoData, channel, pianoTextData, stepLength };\n  if (midiType != undefined) {\n    requestBody['midiType'] = midiType\n  }\n  const response = await fetch(patternsUrl(projectId, patternId), {\n    method: 'PUT',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(requestBody) // body data type must match \"Content-Type\" header\n  });\n  console.log(`[NETWORK] got a response from server, response succeeded?: ${response.ok}`);\n}\n// tunerArgs == {g: true, gs: false, c: true ...}\n// Returns response when done \nexport const autotuneProject = async (tunerArgs, projectId, token) => {\n  const requestBody = {authenticity_token: token, tuner_args: tunerArgs}\n    const response = await fetch(autoTuneProjectUrl(projectId), {\n    method: 'PUT',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(requestBody) // body data type must match \"Content-Type\" header\n    });\n    return response\n} \n\nexport const generatePatternClip = ({ patternId, projectId }) => {\n  console.log(patternId)\n  return fetch(patternGeneratorUrl(patternId, projectId), {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' }\n  });\n}"]},"metadata":{},"sourceType":"module"}
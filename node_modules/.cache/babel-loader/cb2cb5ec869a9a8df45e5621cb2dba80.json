{"ast":null,"code":"import SingleChannel from \"../SingleChannel\"; // )  (\n//      (   ) )\n//       ) ( (\n//  mrf_______)_\n//  .-'---------|  \n// ( C|/\\/\\/\\/\\/|\n//  '-./\\/\\/\\/\\/|\n//    '_________'\n//     '-------'\n//use this to determine which chanel an input comes from \n//http://computermusicresource.com/MIDI.Commands.html?source=post_page---------------------------\n// M I D I ---- C H A N N E L - M A P P I N G S\n//   .---------.\n//   |.-------.|\n//   ||>run#  ||\n//   ||       ||\n//   |\"-------'|etf\n// .-^---------^-.\n// | ---~   AMiGA|\n// \"-------------'\n\nconst ON_CHANNELS = {\n  \"144\": \"1\",\n  \"145\": \"2\",\n  \"146\": \"3\",\n  \"147\": \"4\",\n  \"148\": \"5\",\n  \"149\": \"6\",\n  \"150\": \"7\",\n  \"151\": \"8\",\n  \"152\": \"9\",\n  \"153\": \"10\",\n  \"154\": \"11\",\n  \"155\": \"12\",\n  \"156\": \"13\",\n  \"157\": \"14\",\n  \"158\": \"15\",\n  \"159\": \"16\"\n};\nconst OFF_CHANNELS = {\n  '128': '1',\n  '129': '2',\n  '130': '3',\n  '131': '4',\n  '132': '5',\n  '133': '6',\n  '134': '7',\n  '135': '8',\n  '136': '9',\n  '137': '10',\n  '138': '11',\n  '139': '12',\n  '140': '13',\n  '141': '14',\n  '142': '15',\n  '143': '16' // let this.dirty = false \n  // let this.channelsAndStamps = []\n  //   /////setup audio recording \n  // let this.gumStream;\n  //   //stream from getUserMedia() \n  // let rec;\n  //   //Recorder.js object \n  // let input;\n  //   RECORD THAT MIDI.... FAST\n  // +--^----------,--------,-----,--------^-,\n  //  | |||||||||   `--------'     |          O\n  //  `+---------------------------^----------|\n  //    `\\_,---------,---------,--------------'\n  //      / XXXXXX /'|       /'\n  //     / XXXXXX /  `\\    /'\n  //    / XXXXXX /`-------'\n  //   / XXXXXX /\n  //  / XXXXXX /\n  // (________(                \n  //  `------'   \n\n};\nexport default class SingleChannelHelper {\n  constructor(doc, window) {\n    this.iterableEmojis = [\"✌\", \"😂\", \"😝\", \"😁\", \"😱\", \"👉\", \"🙌\", \"🍻\", \"🔥\", \"🌈\", \"☀\", \"🎈\", \"🌹\", \"💄\", \"🎀\", \"⚽\", \"🎾\", \"🏁\", \"😡\", \"👿\", \"🐻\", \"🐶\", \"🐬\", \"🐟\", \"🍀\", \"👀\", \"🚗\", \"🍎\", \"💝\", \"💙\", \"👌\", \"❤\", \"😍\", \"😉\", \"😓\", \"😳\", \"💪\", \"💩\", \"🍸\", \"🔑\", \"💖\", \"🌟\", \"🎉\", \"🌺\", \"🎶\", \"👠\", \"🏈\", \"⚾\", \"🏆\", \"👽\", \"💀\", \"🐵\", \"🐮\", \"🐩\", \"🐎\", \"💣\", \"👃\", \"👂\", \"🍓\", \"💘\", \"💜\", \"👊\", \"💋\", \"😘\", \"😜\", \"😵\", \"🙏\", \"👋\", \"🚽\", \"💃\", \"💎\", \"🚀\", \"🌙\", \"🎁\", \"⛄\", \"🌊\", \"⛵\", \"🏀\", \"🎱\", \"💰\", \"👶\", \"👸\", \"🐰\", \"🐷\", \"🐍\", \"🐫\", \"🔫\", \"👄\", \"🚲\", \"🍉\", \"💛\", \"💚\"];\n    this.channelsAndStamps = [];\n    this.window = window;\n    this.document = doc;\n    this.dirty = false;\n    this.gumStream = null;\n    this.input = null;\n    this.rec = null;\n  } //first thing that needs to happen \n  //get connection to opz \n\n\n  requestMIDIAccess() {\n    //comes from the navigator object (as per usual, thats where all the good stuff is in chrome anyway)\n    navigator.requestMIDIAccess().then(access => {\n      //there should really only be one here, but you never know \n      console.log(access.inputs); //iterate through a hopefully small array to find the midi device we care about\n\n      const devices = access.inputs.values(); //ditto \n\n      for (let device of devices) {\n        //we are setting some events we need to fire and process for capturing each event AND\n        //when the use turns of the opz, we'll send our message\n        //we need to swap this out with a record button. \n        if (device.name == \"OP-Z\") {\n          device.onmidimessage = this.onMidiMessage; //keep\n\n          device.onstatechange = this.handleOPZChange; //change to have msg sent when we hit stop button \n        }\n      }\n    }).catch(console.error);\n  } //once we send the enire huge json of midi to server, we need to notify the user TODO\n\n\n  onMidiSentSuccess(response) {\n    //TODO: notify success\n    console.log(response);\n  } //literally fires every time a midi msg is sent from the opz  \n\n\n  onMidiMessage(message) {\n    //message data 0 is telling us if we are an off or on channel and which channel (1 - 16) at the same time \n    console.log(message.data[0].toString()); //if its an on channel or off, its relevant, so commit it to the json \n\n    if (ON_CHANNELS[message.data[0].toString()] != undefined || OFF_CHANNELS[message.data[0].toString()] != undefined) {\n      //useless var, we should only begin recording once the user hits record. Remove tonight \n      !this.dirty ? this.setupAndBeginRecording() : \"\";\n      this.dirty = true; //here we push into an unprocessed array, we shall return to this in a while. \n\n      this.channelsAndStamps.push({\n        \"noteChannel\": message.data[0],\n        \"timeStamp\": event.timeStamp\n      }); //////FOR FUN :)DDD///////\n      ///  <<<<<<<><>>>>>>>>>>>..\n      //////////////////////////\n\n      this.document.getElementById(\"div\").style[\"background-color\"] = '#' + Math.floor(Math.random() * 16777215).toString(16); ////more fuuuuuuuuuuuuuuun\n\n      this.document.getElementById(\"iterableEmoji\").innerText = this.iterableEmojis[Math.round(Math.random() * (this.iterableEmojis.length - 1))];\n    }\n  } // send data once opz is disconnected\n\n\n  handleOPZChange(arg) {\n    if (arg.currentTarget.state == \"disconnected\") {\n      this.sendDataMidi(); //colects BLOB and sends the audio to the server\n\n      this.stopRecording();\n    }\n  }\n\n  sendDataMidi() {\n    const Http = new XMLHttpRequest();\n    const url = \"http://localhost:3000/midi\";\n    Http.open(\"POST\", url);\n    Http.setRequestHeader(\"Content-Type\", \"application/json;charset=UTF-8\");\n    Http.send(JSON.stringify(this.channelsAndStamps));\n    Http.onreadystatechange = this.onMidiSentSuccess;\n  }\n\n  setupAndBeginRecording() {\n    // shim for AudioContext when it's not avb. \n    let AudioContext = this.window.AudioContext || this.window.webkitAudioContext;\n    let audioContext = new AudioContext(); //new audio context to help us record \n\n    let constraints = {\n      audio: true,\n      video: false\n    };\n    navigator.mediaDevices.getUserMedia(constraints).then(stream => {\n      console.log(\"getUserMedia() success, stream created, initializing Recorder.js ...\");\n      /* assign to this.gumStream for later use */\n\n      this.gumStream = stream;\n      /* use the stream */\n\n      this.input = audioContext.createMediaStreamSource(stream); //stereo \n\n      rec = new Recorder(this.input, {\n        numChannels: 2\n      }); //start the recording process \n\n      this.rec.record();\n      console.log(\"Recording started\");\n    }).catch(function (err) {\n      console.log(\"couldnt get user media becuase: \".concat(err));\n    });\n  }\n\n  stopRecording() {\n    console.log(\"recording stopped\"); //tell the recorder to stop the recording \n\n    this.rec.stop(); //stop microphone access \n\n    this.gumStream.getAudioTracks()[0].stop(); //create the wav blob and pass it on to createDownloadLink \n\n    this.rec.exportWAV(this.sendAudio);\n  }\n\n  sendAudio(blob) {\n    let xhr = new XMLHttpRequest();\n\n    xhr.onload = e => {\n      if (this.readyState === 4) {\n        console.log(\"Server returned: \", e.target.responseText);\n      }\n    };\n\n    var fd = new FormData();\n    fd.append(\"audio_data\", blob, \"test.wav\");\n    xhr.open(\"POST\", \"http://localhost:3000/audio\", true);\n    xhr.send(fd);\n    console.log(\"send req for song audio\");\n  } //   /|\n  //        =  =  =      / |\n  //   ____| || || |____/  | -_-_-_-_-_-_\n  // |)----| || || |____   |    MAGIC HAPPENS HERE CUZ WE NEED TO MAKE USER CLICK FIRST NOW \n  //   ((  | || || |  ))\\  | _-_-_-_-_-_-\n  //    \\\\_|_||_||_|_//  \\ |\n  //     \\___________/    \\|\n  // main(){\n  //   requestMIDIAccess()     \n  // } //end main\n  // setListener(){\n  //   this.document.getElementById(\"div\").addEventListener(\"click\", main)\n  // }\n  // this.window.onload = setListener;\n\n\n}","map":{"version":3,"sources":["/Users/zackrowden/Desktop/video/fertvertfront/src/classes/SingleChannelHelper.js"],"names":["SingleChannel","ON_CHANNELS","OFF_CHANNELS","SingleChannelHelper","constructor","doc","window","iterableEmojis","channelsAndStamps","document","dirty","gumStream","input","rec","requestMIDIAccess","navigator","then","access","console","log","inputs","devices","values","device","name","onmidimessage","onMidiMessage","onstatechange","handleOPZChange","catch","error","onMidiSentSuccess","response","message","data","toString","undefined","setupAndBeginRecording","push","event","timeStamp","getElementById","style","Math","floor","random","innerText","round","length","arg","currentTarget","state","sendDataMidi","stopRecording","Http","XMLHttpRequest","url","open","setRequestHeader","send","JSON","stringify","onreadystatechange","AudioContext","webkitAudioContext","audioContext","constraints","audio","video","mediaDevices","getUserMedia","stream","createMediaStreamSource","Recorder","numChannels","record","err","stop","getAudioTracks","exportWAV","sendAudio","blob","xhr","onload","e","readyState","target","responseText","fd","FormData","append"],"mappings":"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","sourcesContent":["import SingleChannel from \"../SingleChannel\";\n\n// )  (\n//      (   ) )\n//       ) ( (\n//  mrf_______)_\n//  .-'---------|  \n// ( C|/\\/\\/\\/\\/|\n//  '-./\\/\\/\\/\\/|\n//    '_________'\n//     '-------'\n\n//use this to determine which chanel an input comes from \n\n//http://computermusicresource.com/MIDI.Commands.html?source=post_page---------------------------\n\n// M I D I ---- C H A N N E L - M A P P I N G S\n//   .---------.\n//   |.-------.|\n//   ||>run#  ||\n//   ||       ||\n//   |\"-------'|etf\n// .-^---------^-.\n// | ---~   AMiGA|\n// \"-------------'\n\nconst ON_CHANNELS = {\n    \"144\": \"1\",\n    \"145\": \"2\",\n    \"146\": \"3\",\n    \"147\": \"4\",\n    \"148\": \"5\",\n    \"149\": \"6\",\n    \"150\": \"7\",\n    \"151\": \"8\",\n    \"152\": \"9\",\n    \"153\": \"10\",\n    \"154\": \"11\",\n    \"155\": \"12\",\n    \"156\": \"13\",\n    \"157\": \"14\",\n    \"158\": \"15\",\n    \"159\": \"16\"\n}\nconst OFF_CHANNELS = {\n    '128': '1',\n    '129': '2',\n    '130': '3',\n    '131': '4',\n    '132': '5',\n    '133': '6',\n    '134': '7',\n    '135': '8',\n    '136': '9',\n    '137': '10',\n    '138': '11',\n    '139': '12',\n    '140': '13',\n    '141': '14',\n    '142': '15',\n    '143': '16'\n}\n\n// let this.dirty = false \n\n// let this.channelsAndStamps = []\n//   /////setup audio recording \n// let this.gumStream;\n//   //stream from getUserMedia() \n// let rec;\n//   //Recorder.js object \n// let input;\n\n\n\n//   RECORD THAT MIDI.... FAST\n// +--^----------,--------,-----,--------^-,\n//  | |||||||||   `--------'     |          O\n//  `+---------------------------^----------|\n//    `\\_,---------,---------,--------------'\n//      / XXXXXX /'|       /'\n//     / XXXXXX /  `\\    /'\n//    / XXXXXX /`-------'\n//   / XXXXXX /\n//  / XXXXXX /\n// (________(                \n//  `------'   \n\n\nexport default class SingleChannelHelper {\n\n\n    constructor(doc, window) {\n        this.iterableEmojis = [\"✌\",\"😂\",\"😝\",\"😁\",\"😱\",\"👉\",\"🙌\",\"🍻\",\"🔥\",\"🌈\",\"☀\",\"🎈\",\"🌹\",\"💄\",\"🎀\",\"⚽\",\"🎾\",\"🏁\",\"😡\",\"👿\",\"🐻\",\"🐶\",\"🐬\",\"🐟\",\"🍀\",\"👀\",\"🚗\",\"🍎\",\"💝\",\"💙\",\"👌\",\"❤\",\"😍\",\"😉\",\"😓\",\"😳\",\"💪\",\"💩\",\"🍸\",\"🔑\",\"💖\",\"🌟\",\"🎉\",\"🌺\",\"🎶\",\"👠\",\"🏈\",\"⚾\",\"🏆\",\"👽\",\"💀\",\"🐵\",\"🐮\",\"🐩\",\"🐎\",\"💣\",\"👃\",\"👂\",\"🍓\",\"💘\",\"💜\",\"👊\",\"💋\",\"😘\",\"😜\",\"😵\",\"🙏\",\"👋\",\"🚽\",\"💃\",\"💎\",\"🚀\",\"🌙\",\"🎁\",\"⛄\",\"🌊\",\"⛵\",\"🏀\",\"🎱\",\"💰\",\"👶\",\"👸\",\"🐰\",\"🐷\",\"🐍\",\"🐫\",\"🔫\",\"👄\",\"🚲\",\"🍉\",\"💛\",\"💚\"]\n        this.channelsAndStamps = []\n        this.window = window;\n        this.document = doc;\n        this.dirty = false;\n        this.gumStream = null;\n        this.input = null;\n        this.rec = null;\n    }\n\n    //first thing that needs to happen \n    //get connection to opz \n    requestMIDIAccess() {\n        //comes from the navigator object (as per usual, thats where all the good stuff is in chrome anyway)\n        navigator.requestMIDIAccess().then( access => {\n          //there should really only be one here, but you never know \n          console.log(access.inputs);\n          //iterate through a hopefully small array to find the midi device we care about\n          const devices = access.inputs.values();\n          //ditto \n          for (let device of devices ) {\n            //we are setting some events we need to fire and process for capturing each event AND\n            //when the use turns of the opz, we'll send our message\n            //we need to swap this out with a record button. \n            if (device.name == \"OP-Z\") {\n              device.onmidimessage = this.onMidiMessage //keep\n              device.onstatechange = this.handleOPZChange //change to have msg sent when we hit stop button \n            }\n\n          }\n        }).catch(console.error);\n    }\n    //once we send the enire huge json of midi to server, we need to notify the user TODO\n    onMidiSentSuccess(response){\n        //TODO: notify success\n        console.log(response);\n    }\n    //literally fires every time a midi msg is sent from the opz  \n    onMidiMessage(message){\n      //message data 0 is telling us if we are an off or on channel and which channel (1 - 16) at the same time \n      console.log(message.data[0].toString())\n      //if its an on channel or off, its relevant, so commit it to the json \n      if ((ON_CHANNELS[message.data[0].toString()] != undefined) || (OFF_CHANNELS[message.data[0].toString()] != undefined)) {\n        //useless var, we should only begin recording once the user hits record. Remove tonight \n        !this.dirty ? this.setupAndBeginRecording() : \"\"\n         this.dirty = true \n        //here we push into an unprocessed array, we shall return to this in a while. \n        this.channelsAndStamps.push({\"noteChannel\": message.data[0], \"timeStamp\": event.timeStamp })\n        //////FOR FUN :)DDD///////\n        ///  <<<<<<<><>>>>>>>>>>>..\n        //////////////////////////\n        this.document.getElementById(\"div\").style[\"background-color\"] = '#'+Math.floor(Math.random()*16777215).toString(16)\n        ////more fuuuuuuuuuuuuuuun\n        this.document.getElementById(\"iterableEmoji\").innerText = this.iterableEmojis[Math.round(Math.random() * (this.iterableEmojis.length - 1))]\n      } \n    }\n    \n      // send data once opz is disconnected\n    handleOPZChange(arg) {\n\n      if(arg.currentTarget.state == \"disconnected\") {\n        this.sendDataMidi();\n        //colects BLOB and sends the audio to the server\n        this.stopRecording();\n      }\n\n    }\n    \n    sendDataMidi(){\n         const Http = new XMLHttpRequest();\n         const url = \"http://localhost:3000/midi\"\n         Http.open(\"POST\", url);\n         Http.setRequestHeader(\"Content-Type\", \"application/json;charset=UTF-8\");\n         Http.send(JSON.stringify(this.channelsAndStamps));\n    \n         Http.onreadystatechange = this.onMidiSentSuccess; \n    }\n    \n    setupAndBeginRecording(){\n        // shim for AudioContext when it's not avb. \n        let AudioContext = this.window.AudioContext || this.window.webkitAudioContext;\n        let audioContext = new AudioContext;\n      //new audio context to help us record \n        let constraints = {\n          audio: true,\n          video: false\n        } \n        navigator.mediaDevices.getUserMedia(constraints).then((stream) => {\n          console.log(\"getUserMedia() success, stream created, initializing Recorder.js ...\"); \n          /* assign to this.gumStream for later use */\n          this.gumStream = stream;\n          /* use the stream */\n          this.input = audioContext.createMediaStreamSource(stream);\n          //stereo \n          rec = new Recorder(this.input, {\n              numChannels: 2\n          }) \n          //start the recording process \n          this.rec.record()\n          console.log(\"Recording started\");\n        }).catch(function(err) {\n            console.log(`couldnt get user media becuase: ${err}`)\n        });\n    }\n    \n    \n    stopRecording(){\n        console.log(\"recording stopped\")\n        //tell the recorder to stop the recording \n        this.rec.stop(); //stop microphone access \n        this.gumStream.getAudioTracks()[0].stop();\n        //create the wav blob and pass it on to createDownloadLink \n        this.rec.exportWAV(this.sendAudio);\n    }\n    \n    \n    sendAudio(blob){\n      let xhr = new XMLHttpRequest();\n      xhr.onload = (e) => {\n          if (this.readyState === 4) {\n              console.log(\"Server returned: \", e.target.responseText);\n          }\n      };\n      var fd = new FormData();\n      fd.append(\"audio_data\", blob, \"test.wav\");\n      xhr.open(\"POST\", \"http://localhost:3000/audio\", true);\n      xhr.send(fd);\n      console.log(\"send req for song audio\")\n    }\n    //   /|\n    //        =  =  =      / |\n    //   ____| || || |____/  | -_-_-_-_-_-_\n    // |)----| || || |____   |    MAGIC HAPPENS HERE CUZ WE NEED TO MAKE USER CLICK FIRST NOW \n    //   ((  | || || |  ))\\  | _-_-_-_-_-_-\n    //    \\\\_|_||_||_|_//  \\ |\n    //     \\___________/    \\|\n    \n    \n    // main(){\n    //   requestMIDIAccess()     \n    // } //end main\n    \n    \n    // setListener(){\n    //   this.document.getElementById(\"div\").addEventListener(\"click\", main)\n    // }\n    // this.window.onload = setListener;\n\n}\n\n"]},"metadata":{},"sourceType":"module"}
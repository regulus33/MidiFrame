{"ast":null,"code":"// )  (\n//      (   ) )\n//       ) ( (\n//  mrf_______)_\n//  .-'---------|  \n// ( C|/\\/\\/\\/\\/|\n//  '-./\\/\\/\\/\\/|\n//    '_________'\n//     '-------'\n//use this to determine which chanel an input comes from \n//http://computermusicresource.com/MIDI.Commands.html?source=post_page---------------------------\n// M I D I ---- C H A N N E L - M A P P I N G S\n//   .---------.\n//   |.-------.|\n//   ||>run#  ||\n//   ||       ||\n//   |\"-------'|etf\n// .-^---------^-.\n// | ---~   AMiGA|\n// \"-------------'\nconst ON_CHANNELS = {\n  \"144\": \"1\",\n  \"145\": \"2\",\n  \"146\": \"3\",\n  \"147\": \"4\",\n  \"148\": \"5\",\n  \"149\": \"6\",\n  \"150\": \"7\",\n  \"151\": \"8\",\n  \"152\": \"9\",\n  \"153\": \"10\",\n  \"154\": \"11\",\n  \"155\": \"12\",\n  \"156\": \"13\",\n  \"157\": \"14\",\n  \"158\": \"15\",\n  \"159\": \"16\"\n};\nconst OFF_CHANNELS = {\n  '128': '1',\n  '129': '2',\n  '130': '3',\n  '131': '4',\n  '132': '5',\n  '133': '6',\n  '134': '7',\n  '135': '8',\n  '136': '9',\n  '137': '10',\n  '138': '11',\n  '139': '12',\n  '140': '13',\n  '141': '14',\n  '142': '15',\n  '143': '16' // let this.firstNote = false \n  // let this.channelsAndStamps = []\n  //   /////setup audio recording \n  // let this.gumStream;\n  //   //stream from getUserMedia() \n  // let rec;\n  //   //Recorder.js object \n  // let input;\n  //   RECORD THAT MIDI.... FAST\n  // +--^----------,--------,-----,--------^-,\n  //  | |||||||||   `--------'     |          O\n  //  `+---------------------------^----------|\n  //    `\\_,---------,---------,--------------'\n  //      / XXXXXX /'|       /'\n  //     / XXXXXX /  `\\    /'\n  //    / XXXXXX /`-------'\n  //   / XXXXXX /\n  //  / XXXXXX /\n  // (________(                \n  //  `------'   \n\n};\nexport default class SingleChannelHelper {\n  constructor(doc, _window, recorder) {\n    this.startMidi = () => {\n      //comes from the navigator object (as per usual, thats where all the good stuff is in chrome anyway)\n      navigator.requestMIDIAccess().then(access => {\n        //there should really only be one here, but you never know \n        console.log(access.inputs); //iterate through a hopefully small array to find the midi device we care about\n\n        const devices = access.inputs.values(); //ditto \n\n        for (let device of devices) {\n          //we are setting some events we need to fire and process for capturing each event AND\n          //when the use turns of the opz, we'll send our message\n          //we need to swap this out with a record button. \n          if (device.name == \"OP-Z\") {\n            console.log(device.name);\n            device.onmidimessage = this.onMidiMessage; //keep\n\n            device.onstatechange = this.handleOPZChange; //change to have msg sent when we hit stop button \n          }\n        }\n      }).catch(console.error);\n    };\n\n    this.onMidiMessage = message => {\n      //message data 0 is telling us if we are an off or on channel and which channel (1 - 16) at the same time \n      console.log(message.data[0].toString());\n      console.log(message.timeStamp); //if its an on channel or off, its relevant, so commit it to the json \n\n      if (ON_CHANNELS[message.data[0].toString()] != undefined || OFF_CHANNELS[message.data[0].toString()] != undefined) {\n        //send all midi messages to the server for tests \n        let stringedData = [];\n        message.data.forEach(d => {\n          stringedData.push(d.toString());\n        });\n        let obj = {\n          data: stringedData,\n          timeStamp: message.timeStamp\n        };\n        this.midiForTesting.push(obj); //just fo a minit then we gonna falsify dat shit         \n        //useless var, we should only begin recording once the user hits record. Remove tonight \n\n        console.log(\"midi \" + this.timeOfFirstMidiNote);\n\n        if (this.firstNote == true) {\n          this.timeOfFirstMidiNote = Date.now();\n          console.log(\"first midi \" + this.timeOfFirstMidiNote); // this.setupAndBeginRecording()  \n        }\n\n        this.firstNote = false; //here we push into an unprocessed array, we shall return to this in a while\n\n        this.channelsAndStamps.push({\n          \"noteChannel\": message.data[0],\n          \"timeStamp\": message.timeStamp\n        }); //////FOR FUN :)DDD///////\n        ///  <<<<<<<><>>>>>>>>>>>..\n        //////////////////////////\n\n        this.document.getElementById(\"div\").style[\"background-color\"] = '#' + Math.floor(Math.random() * 16777215).toString(16); ////more fuuuuuuuuuuuuuuun\n\n        this.document.getElementById(\"iterableEmoji\").innerText = this.iterableEmojis[Math.round(Math.random() * (this.iterableEmojis.length - 1))];\n      }\n    };\n\n    this.handleOPZChange = arg => {// if(arg.currentTarget.state == \"disconnected\") {\n      //   this.stopRecording();\n      //   this.sendDataMidi();\n      //   //colects BLOB and sends the audio to the server\n      // }\n    };\n\n    this.onStop = () => {\n      this.stopRecording(); //colects BLOB and sends the audio to the server\n    };\n\n    this.sendDataMidi = offset => {\n      //add offset to request \n      this.channelsAndStamps.push(offset);\n      const Http = new XMLHttpRequest();\n      const url = \"http://localhost:3000/midi\";\n      Http.open(\"POST\", url);\n      Http.setRequestHeader(\"Content-Type\", \"application/json;charset=UTF-8\");\n      Http.send(JSON.stringify(this.midiForTesting));\n      Http.onreadystatechange = this.onMidiSentSuccess;\n    };\n\n    this.setupAndBeginRecording = () => {\n      // shim for AudioContext when it's not avb. \n      let AudioContext = this.window.AudioContext || this.window.webkitAudioContext;\n      let audioContext = new AudioContext(); //new audio context to help us record \n\n      let constraints = {\n        audio: true,\n        video: false\n      };\n      navigator.mediaDevices.getUserMedia(constraints).then(stream => {\n        console.log(\"getUserMedia() success, stream created, initializing Recorder.js ...\");\n        /* assign to this.gumStream for later use */\n\n        this.gumStream = stream;\n        /* use the stream */\n\n        this.input = audioContext.createMediaStreamSource(stream); //stereo \n\n        this.rec = new window.Recorder(this.input, {\n          numChannels: 2\n        }); //start the recording process \n\n        this.timeOfFirstRecord = Date.now();\n        this.rec.record();\n        console.log(\"Recording started\");\n      }).catch(function (err) {\n        console.log(\"couldnt get user media becuase: \".concat(err));\n      });\n    };\n\n    this.stopRecording = () => {\n      console.log(\"recording stopped\"); //tell the recorder to stop the recording \n\n      this.rec.stop(); //stop microphone access \n\n      this.gumStream.getAudioTracks()[0].stop(); //create the wav blob and pass it on to createDownloadLink \n\n      this.rec.exportWAV(this.sendAudio);\n      this.sendDataMidi(2);\n    };\n\n    this.sendAudio = blob => {\n      let xhr = new XMLHttpRequest();\n\n      xhr.onload = e => {\n        if (this.readyState === 4) {\n          console.log(\"Server returned: \", e.target.responseText);\n        }\n      };\n\n      var fd = new FormData();\n      fd.append(\"audio_data\", blob, \"test.wav\");\n      xhr.open(\"POST\", \"http://localhost:3000/audio\", true);\n      xhr.send(fd);\n\n      xhr.onreadystatechange = res => {\n        console.log(xhr.status);\n\n        if (xhr.status === 200 && this.firstTime === true) {\n          let offset = this._millisToSeconds(this.timeOfFirstRecord - this.timeOfFirstMidiNote); // this.sendDataMidi(offset);\n\n\n          this.firstTime = false;\n        } else {\n          console.log('failed to audio for some reason');\n        }\n\n        console.log(\"audio uploaded\");\n        console.log(\"hopefully? the values of offset will be calculated at runtime and not compile time, and hopefully I'm at least a little bit not a complete idiot\"); //send the midi request here\n      };\n\n      console.log(\"send req for song audio\");\n    };\n\n    this.iterableEmojis = [\"âœŒ\", \"ðŸ˜‚\", \"ðŸ˜\", \"ðŸ˜\", \"ðŸ˜±\", \"ðŸ‘‰\", \"ðŸ™Œ\", \"ðŸ»\", \"ðŸ”¥\", \"ðŸŒˆ\", \"â˜€\", \"ðŸŽˆ\", \"ðŸŒ¹\", \"ðŸ’„\", \"ðŸŽ€\", \"âš½\", \"ðŸŽ¾\", \"ðŸ\", \"ðŸ˜¡\", \"ðŸ‘¿\", \"ðŸ»\", \"ðŸ¶\", \"ðŸ¬\", \"ðŸŸ\", \"ðŸ€\", \"ðŸ‘€\", \"ðŸš—\", \"ðŸŽ\", \"ðŸ’\", \"ðŸ’™\", \"ðŸ‘Œ\", \"â¤\", \"ðŸ˜\", \"ðŸ˜‰\", \"ðŸ˜“\", \"ðŸ˜³\", \"ðŸ’ª\", \"ðŸ’©\", \"ðŸ¸\", \"ðŸ”‘\", \"ðŸ’–\", \"ðŸŒŸ\", \"ðŸŽ‰\", \"ðŸŒº\", \"ðŸŽ¶\", \"ðŸ‘ \", \"ðŸˆ\", \"âš¾\", \"ðŸ†\", \"ðŸ‘½\", \"ðŸ’€\", \"ðŸµ\", \"ðŸ®\", \"ðŸ©\", \"ðŸŽ\", \"ðŸ’£\", \"ðŸ‘ƒ\", \"ðŸ‘‚\", \"ðŸ“\", \"ðŸ’˜\", \"ðŸ’œ\", \"ðŸ‘Š\", \"ðŸ’‹\", \"ðŸ˜˜\", \"ðŸ˜œ\", \"ðŸ˜µ\", \"ðŸ™\", \"ðŸ‘‹\", \"ðŸš½\", \"ðŸ’ƒ\", \"ðŸ’Ž\", \"ðŸš€\", \"ðŸŒ™\", \"ðŸŽ\", \"â›„\", \"ðŸŒŠ\", \"â›µ\", \"ðŸ€\", \"ðŸŽ±\", \"ðŸ’°\", \"ðŸ‘¶\", \"ðŸ‘¸\", \"ðŸ°\", \"ðŸ·\", \"ðŸ\", \"ðŸ«\", \"ðŸ”«\", \"ðŸ‘„\", \"ðŸš²\", \"ðŸ‰\", \"ðŸ’›\", \"ðŸ’š\"];\n    this.channelsAndStamps = [];\n    this.window = _window;\n    this.document = doc;\n    this.firstNote = true;\n    this.gumStream = null;\n    this.input = null;\n    this.rec = null;\n    this.timeOfFirstMidiNote = null;\n    this.timeOfFirstRecord = null;\n    this.firstTime = true;\n    this.midiForTesting = [];\n  } //first thing that needs to happen \n  //get connection to opz \n\n\n  //once we send the enire huge json of midi to server, we need to notify the user TODO\n  onMidiSentSuccess(response) {\n    //TODO: notify success\n    console.log(\"the midi request ended\");\n  } //literally fires every time a midi msg is sent from the opz  \n\n\n  _millisToSeconds(millis) {\n    return millis / 1000;\n  } //   /|\n  //        =  =  =      / |\n  //   ____| || || |____/  | -_-_-_-_-_-_\n  // |)----| || || |____   |    MAGIC HAPPENS HERE CUZ WE NEED TO MAKE USER CLICK FIRST NOW \n  //   ((  | || || |  ))\\  | _-_-_-_-_-_-\n  //    \\\\_|_||_||_|_//  \\ |\n  //     \\___________/    \\|\n  // main(){\n  //   requestMIDIAccess()     \n  // } //end main\n  // setListener(){\n  //   this.document.getElementById(\"div\").addEventListener(\"click\", main)\n  // }\n  // this.window.onload = setListener;\n\n\n}","map":{"version":3,"sources":["/Users/zacharyrowden/Desktop/notes/src/classes/SingleChannelHelper.js"],"names":["ON_CHANNELS","OFF_CHANNELS","SingleChannelHelper","constructor","doc","window","recorder","startMidi","navigator","requestMIDIAccess","then","access","console","log","inputs","devices","values","device","name","onmidimessage","onMidiMessage","onstatechange","handleOPZChange","catch","error","message","data","toString","timeStamp","undefined","stringedData","forEach","d","push","obj","midiForTesting","timeOfFirstMidiNote","firstNote","Date","now","channelsAndStamps","document","getElementById","style","Math","floor","random","innerText","iterableEmojis","round","length","arg","onStop","stopRecording","sendDataMidi","offset","Http","XMLHttpRequest","url","open","setRequestHeader","send","JSON","stringify","onreadystatechange","onMidiSentSuccess","setupAndBeginRecording","AudioContext","webkitAudioContext","audioContext","constraints","audio","video","mediaDevices","getUserMedia","stream","gumStream","input","createMediaStreamSource","rec","Recorder","numChannels","timeOfFirstRecord","record","err","stop","getAudioTracks","exportWAV","sendAudio","blob","xhr","onload","e","readyState","target","responseText","fd","FormData","append","res","status","firstTime","_millisToSeconds","response","millis"],"mappings":"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","sourcesContent":["\n// )  (\n//      (   ) )\n//       ) ( (\n//  mrf_______)_\n//  .-'---------|  \n// ( C|/\\/\\/\\/\\/|\n//  '-./\\/\\/\\/\\/|\n//    '_________'\n//     '-------'\n\n//use this to determine which chanel an input comes from \n\n//http://computermusicresource.com/MIDI.Commands.html?source=post_page---------------------------\n\n// M I D I ---- C H A N N E L - M A P P I N G S\n//   .---------.\n//   |.-------.|\n//   ||>run#  ||\n//   ||       ||\n//   |\"-------'|etf\n// .-^---------^-.\n// | ---~   AMiGA|\n// \"-------------'\n\nconst ON_CHANNELS = {\n    \"144\": \"1\",\n    \"145\": \"2\",\n    \"146\": \"3\",\n    \"147\": \"4\",\n    \"148\": \"5\",\n    \"149\": \"6\",\n    \"150\": \"7\",\n    \"151\": \"8\",\n    \"152\": \"9\",\n    \"153\": \"10\",\n    \"154\": \"11\",\n    \"155\": \"12\",\n    \"156\": \"13\",\n    \"157\": \"14\",\n    \"158\": \"15\",\n    \"159\": \"16\"\n}\nconst OFF_CHANNELS = {\n    '128': '1',\n    '129': '2',\n    '130': '3',\n    '131': '4',\n    '132': '5',\n    '133': '6',\n    '134': '7',\n    '135': '8',\n    '136': '9',\n    '137': '10',\n    '138': '11',\n    '139': '12',\n    '140': '13',\n    '141': '14',\n    '142': '15',\n    '143': '16'\n}\n\n// let this.firstNote = false \n\n// let this.channelsAndStamps = []\n//   /////setup audio recording \n// let this.gumStream;\n//   //stream from getUserMedia() \n// let rec;\n//   //Recorder.js object \n// let input;\n\n//   RECORD THAT MIDI.... FAST\n// +--^----------,--------,-----,--------^-,\n//  | |||||||||   `--------'     |          O\n//  `+---------------------------^----------|\n//    `\\_,---------,---------,--------------'\n//      / XXXXXX /'|       /'\n//     / XXXXXX /  `\\    /'\n//    / XXXXXX /`-------'\n//   / XXXXXX /\n//  / XXXXXX /\n// (________(                \n//  `------'   \n\n\nexport default class SingleChannelHelper {\n\n\n    constructor(doc, window, recorder) {\n        this.iterableEmojis = [\"âœŒ\",\"ðŸ˜‚\",\"ðŸ˜\",\"ðŸ˜\",\"ðŸ˜±\",\"ðŸ‘‰\",\"ðŸ™Œ\",\"ðŸ»\",\"ðŸ”¥\",\"ðŸŒˆ\",\"â˜€\",\"ðŸŽˆ\",\"ðŸŒ¹\",\"ðŸ’„\",\"ðŸŽ€\",\"âš½\",\"ðŸŽ¾\",\"ðŸ\",\"ðŸ˜¡\",\"ðŸ‘¿\",\"ðŸ»\",\"ðŸ¶\",\"ðŸ¬\",\"ðŸŸ\",\"ðŸ€\",\"ðŸ‘€\",\"ðŸš—\",\"ðŸŽ\",\"ðŸ’\",\"ðŸ’™\",\"ðŸ‘Œ\",\"â¤\",\"ðŸ˜\",\"ðŸ˜‰\",\"ðŸ˜“\",\"ðŸ˜³\",\"ðŸ’ª\",\"ðŸ’©\",\"ðŸ¸\",\"ðŸ”‘\",\"ðŸ’–\",\"ðŸŒŸ\",\"ðŸŽ‰\",\"ðŸŒº\",\"ðŸŽ¶\",\"ðŸ‘ \",\"ðŸˆ\",\"âš¾\",\"ðŸ†\",\"ðŸ‘½\",\"ðŸ’€\",\"ðŸµ\",\"ðŸ®\",\"ðŸ©\",\"ðŸŽ\",\"ðŸ’£\",\"ðŸ‘ƒ\",\"ðŸ‘‚\",\"ðŸ“\",\"ðŸ’˜\",\"ðŸ’œ\",\"ðŸ‘Š\",\"ðŸ’‹\",\"ðŸ˜˜\",\"ðŸ˜œ\",\"ðŸ˜µ\",\"ðŸ™\",\"ðŸ‘‹\",\"ðŸš½\",\"ðŸ’ƒ\",\"ðŸ’Ž\",\"ðŸš€\",\"ðŸŒ™\",\"ðŸŽ\",\"â›„\",\"ðŸŒŠ\",\"â›µ\",\"ðŸ€\",\"ðŸŽ±\",\"ðŸ’°\",\"ðŸ‘¶\",\"ðŸ‘¸\",\"ðŸ°\",\"ðŸ·\",\"ðŸ\",\"ðŸ«\",\"ðŸ”«\",\"ðŸ‘„\",\"ðŸš²\",\"ðŸ‰\",\"ðŸ’›\",\"ðŸ’š\"]\n        this.channelsAndStamps = []\n        this.window = window;\n        this.document = doc;\n        this.firstNote = true;\n        this.gumStream = null;\n        this.input = null;\n        this.rec = null;\n        this.timeOfFirstMidiNote = null;\n        this.timeOfFirstRecord = null;\n        this.firstTime = true;\n        this.midiForTesting = [];\n    }\n\n\n\n    //first thing that needs to happen \n    //get connection to opz \n    startMidi = () => {\n        //comes from the navigator object (as per usual, thats where all the good stuff is in chrome anyway)\n        navigator.requestMIDIAccess().then( access => {\n          //there should really only be one here, but you never know \n          console.log(access.inputs);\n          //iterate through a hopefully small array to find the midi device we care about\n          const devices = access.inputs.values();\n          //ditto \n          for (let device of devices ) {\n            //we are setting some events we need to fire and process for capturing each event AND\n            //when the use turns of the opz, we'll send our message\n            //we need to swap this out with a record button. \n            if (device.name == \"OP-Z\") {\n              console.log(device.name)\n              device.onmidimessage = this.onMidiMessage //keep\n              device.onstatechange = this.handleOPZChange //change to have msg sent when we hit stop button \n            }\n\n          }\n        }).catch(console.error);\n    }\n    //once we send the enire huge json of midi to server, we need to notify the user TODO\n    onMidiSentSuccess(response){\n        //TODO: notify success\n        console.log(\"the midi request ended\");\n    }\n    //literally fires every time a midi msg is sent from the opz  \n    onMidiMessage = (message) => {\n      //message data 0 is telling us if we are an off or on channel and which channel (1 - 16) at the same time \n      console.log(message.data[0].toString())\n      console.log(message.timeStamp)\n      //if its an on channel or off, its relevant, so commit it to the json \n      if ((ON_CHANNELS[message.data[0].toString()] != undefined) || (OFF_CHANNELS[message.data[0].toString()] != undefined)) {\n        \n        //send all midi messages to the server for tests \n        \n        let stringedData = []\n        message.data.forEach((d)=>{stringedData.push(d.toString())})\n        let obj = {\n          data: stringedData,\n          timeStamp: message.timeStamp\n        }\n\n        this.midiForTesting.push(obj)\n\n        //just fo a minit then we gonna falsify dat shit         \n        //useless var, we should only begin recording once the user hits record. Remove tonight \n        console.log(\"midi \" +this.timeOfFirstMidiNote )\n        if(this.firstNote == true){\n          this.timeOfFirstMidiNote = Date.now()\n          console.log(\"first midi \" +this.timeOfFirstMidiNote )\n\n          // this.setupAndBeginRecording()  \n        } \n         this.firstNote = false \n        //here we push into an unprocessed array, we shall return to this in a while\n        this.channelsAndStamps.push({\"noteChannel\": message.data[0], \"timeStamp\": message.timeStamp })\n        //////FOR FUN :)DDD///////\n        ///  <<<<<<<><>>>>>>>>>>>..\n        //////////////////////////\n        this.document.getElementById(\"div\").style[\"background-color\"] = '#'+Math.floor(Math.random()*16777215).toString(16)\n        ////more fuuuuuuuuuuuuuuun\n        this.document.getElementById(\"iterableEmoji\").innerText = this.iterableEmojis[Math.round(Math.random() * (this.iterableEmojis.length - 1))]\n      } \n    }\n    \n    // send data once opz is disconnected\n    handleOPZChange = (arg) => {\n\n      // if(arg.currentTarget.state == \"disconnected\") {\n      //   this.stopRecording();\n      //   this.sendDataMidi();\n      //   //colects BLOB and sends the audio to the server\n      // }\n\n    }\n\n    onStop = () => {\n      \n      this.stopRecording();\n    \n      //colects BLOB and sends the audio to the server\n\n    }\n    \n    sendDataMidi = (offset) => {\n        //add offset to request \n        this.channelsAndStamps.push(offset)\n         const Http = new XMLHttpRequest();\n         const url = \"http://localhost:3000/midi\"\n         Http.open(\"POST\", url);\n         Http.setRequestHeader(\"Content-Type\", \"application/json;charset=UTF-8\");\n         Http.send(JSON.stringify(this.midiForTesting));\n    \n         Http.onreadystatechange = this.onMidiSentSuccess; \n    }\n    \n    setupAndBeginRecording = () => {\n        // shim for AudioContext when it's not avb. \n        let AudioContext = this.window.AudioContext || this.window.webkitAudioContext;\n        let audioContext = new AudioContext;\n      //new audio context to help us record \n        let constraints = {\n          audio: true,\n          video: false\n        } \n        navigator.mediaDevices.getUserMedia(constraints).then((stream) => {\n          console.log(\"getUserMedia() success, stream created, initializing Recorder.js ...\"); \n          /* assign to this.gumStream for later use */\n          this.gumStream = stream;\n          /* use the stream */\n          this.input = audioContext.createMediaStreamSource(stream);\n          //stereo \n          this.rec = new window.Recorder(this.input, {\n              numChannels: 2\n          }) \n          //start the recording process \n          this.timeOfFirstRecord = Date.now()\n          this.rec.record()\n          console.log(\"Recording started\");\n        }).catch(function(err) {\n            console.log(`couldnt get user media becuase: ${err}`)\n        });\n    }\n    \n    stopRecording = () => {\n        console.log(\"recording stopped\")\n        //tell the recorder to stop the recording \n        this.rec.stop(); //stop microphone access \n        this.gumStream.getAudioTracks()[0].stop();\n        //create the wav blob and pass it on to createDownloadLink \n        this.rec.exportWAV(this.sendAudio);\n        this.sendDataMidi(2)\n    }\n    \n    sendAudio = (blob) => {\n      let xhr = new XMLHttpRequest();\n      xhr.onload = (e) => {\n          if (this.readyState === 4) {\n              console.log(\"Server returned: \", e.target.responseText);\n          }\n      };\n      var fd = new FormData();\n      fd.append(\"audio_data\", blob, \"test.wav\");\n      xhr.open(\"POST\", \"http://localhost:3000/audio\", true);\n      xhr.send(fd);\n      xhr.onreadystatechange = (res) => {\n        console.log(xhr.status)\n          if (xhr.status === 200 && this.firstTime === true) {\n            let offset = this._millisToSeconds(this.timeOfFirstRecord - this.timeOfFirstMidiNote)\n            // this.sendDataMidi(offset);\n            this.firstTime = false \n         } else {\n            console.log('failed to audio for some reason');\n         }\n        console.log(\"audio uploaded\")\n        console.log(\"hopefully? the values of offset will be calculated at runtime and not compile time, and hopefully I'm at least a little bit not a complete idiot\")\n  \n\n        \n        //send the midi request here\n      }\n      console.log(\"send req for song audio\")\n    }\n\n\n    _millisToSeconds(millis){\n      return millis/1000\n  }\n    //   /|\n    //        =  =  =      / |\n    //   ____| || || |____/  | -_-_-_-_-_-_\n    // |)----| || || |____   |    MAGIC HAPPENS HERE CUZ WE NEED TO MAKE USER CLICK FIRST NOW \n    //   ((  | || || |  ))\\  | _-_-_-_-_-_-\n    //    \\\\_|_||_||_|_//  \\ |\n    //     \\___________/    \\|\n    \n    \n    // main(){\n    //   requestMIDIAccess()     \n    // } //end main\n    \n    \n    // setListener(){\n    //   this.document.getElementById(\"div\").addEventListener(\"click\", main)\n    // }\n    // this.window.onload = setListener;\n\n}\n\n"]},"metadata":{},"sourceType":"module"}